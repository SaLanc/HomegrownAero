
DasAltimeter.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000e58  00000000  00000000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     0000000c  20000000  00000e58  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000001d0  20000010  00000e68  0002000c  2**3
                  ALLOC
  3 .stack        00002000  200001e0  00001038  0002000c  2**0
                  ALLOC
  4 .ARM.attributes 00000028  00000000  00000000  0002000c  2**0
                  CONTENTS, READONLY
  5 .comment      00000059  00000000  00000000  00020034  2**0
                  CONTENTS, READONLY
  6 .debug_info   0001a4a6  00000000  00000000  0002008d  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001a93  00000000  00000000  0003a533  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    00001bc5  00000000  00000000  0003bfc6  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 00000288  00000000  00000000  0003db8b  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00001c68  00000000  00000000  0003de13  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_macro  00013a89  00000000  00000000  0003fa7b  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   000054f2  00000000  00000000  00053504  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    00075350  00000000  00000000  000589f6  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  000006a0  00000000  00000000  000cdd48  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <exception_table>:
 *         retrieved from cpu registers.
 */
void SystemCoreClockUpdate(void)
{
        // Not implemented
        SystemCoreClock = __SYSTEM_CLOCK;
   0:	e0 21 00 20 19 01 00 00 15 01 00 00 d1 06 00 00     .!. ............
	...
	pinGpio(p);
    PORT->Group[p.group].PINCFG[p.pin].bit.DRVSTR = 1;
}

inline static void pinHigh(Pin p) {
    PORT->Group[p.group].OUTSET.reg = (1<<p.pin);
  2c:	15 01 00 00 00 00 00 00 00 00 00 00 15 01 00 00     ................
    pinLow(cs_mem);
    spiDataOut(MEM_SPI,OPCODE_WRITEENABLE);
    pinHigh(cs_mem);

    pinLow(cs_mem);
    spiDataOut(MEM_SPI,OPCODE_PROGRAM);
  3c:	71 09 00 00 15 01 00 00 15 01 00 00 15 01 00 00     q...............
    spiDataOut(MEM_SPI,((address & 0xFF0000) >> 16));
  4c:	a5 09 00 00 15 01 00 00 15 01 00 00 15 01 00 00     ................
    spiDataOut(MEM_SPI,((address & 0x00FF00) >>  8));
    spiDataOut(MEM_SPI,((address & 0x0000FF) >>  0));
  5c:	15 01 00 00 15 01 00 00 15 01 00 00 15 01 00 00     ................

    for (u8_t pos = 0; pos < len; ++pos) {
  6c:	15 01 00 00 15 01 00 00 15 01 00 00 15 01 00 00     ................
  7c:	15 01 00 00 15 01 00 00 15 01 00 00 15 01 00 00     ................
        spiDataOut(MEM_SPI, bytes[pos]);
    }

    pinHigh(cs_mem);

}
  8c:	79 0a 00 00 f1 0a 00 00 00 00 00 00 00 00 00 00     y...............
  9c:	15 01 00 00 15 01 00 00 15 01 00 00 15 01 00 00     ................
  ac:	15 01 00 00 00 00 00 00                             ........

000000b4 <__do_global_dtors_aux>:
  b4:	b510      	push	{r4, lr}
  b6:	4c06      	ldr	r4, [pc, #24]	; (d0 <__do_global_dtors_aux+0x1c>)
  b8:	7823      	ldrb	r3, [r4, #0]
  ba:	2b00      	cmp	r3, #0
  bc:	d107      	bne.n	ce <__do_global_dtors_aux+0x1a>
  be:	4b05      	ldr	r3, [pc, #20]	; (d4 <__do_global_dtors_aux+0x20>)
  c0:	2b00      	cmp	r3, #0
  c2:	d002      	beq.n	ca <__do_global_dtors_aux+0x16>
  c4:	4804      	ldr	r0, [pc, #16]	; (d8 <__do_global_dtors_aux+0x24>)
  c6:	e000      	b.n	ca <__do_global_dtors_aux+0x16>
  c8:	bf00      	nop
  ca:	2301      	movs	r3, #1
  cc:	7023      	strb	r3, [r4, #0]
  ce:	bd10      	pop	{r4, pc}
  d0:	20000010 	.word	0x20000010
  d4:	00000000 	.word	0x00000000
  d8:	00000e58 	.word	0x00000e58

000000dc <frame_dummy>:
  dc:	4b08      	ldr	r3, [pc, #32]	; (100 <frame_dummy+0x24>)
  de:	b510      	push	{r4, lr}
  e0:	2b00      	cmp	r3, #0
  e2:	d003      	beq.n	ec <frame_dummy+0x10>
  e4:	4907      	ldr	r1, [pc, #28]	; (104 <frame_dummy+0x28>)
  e6:	4808      	ldr	r0, [pc, #32]	; (108 <frame_dummy+0x2c>)
  e8:	e000      	b.n	ec <frame_dummy+0x10>
  ea:	bf00      	nop
  ec:	4807      	ldr	r0, [pc, #28]	; (10c <frame_dummy+0x30>)
  ee:	6803      	ldr	r3, [r0, #0]
  f0:	2b00      	cmp	r3, #0
  f2:	d100      	bne.n	f6 <frame_dummy+0x1a>
  f4:	bd10      	pop	{r4, pc}
  f6:	4b06      	ldr	r3, [pc, #24]	; (110 <frame_dummy+0x34>)
  f8:	2b00      	cmp	r3, #0
  fa:	d0fb      	beq.n	f4 <frame_dummy+0x18>
  fc:	4798      	blx	r3
  fe:	e7f9      	b.n	f4 <frame_dummy+0x18>
 100:	00000000 	.word	0x00000000
 104:	20000014 	.word	0x20000014
 108:	00000e58 	.word	0x00000e58
 10c:	00000e58 	.word	0x00000e58
 110:	00000000 	.word	0x00000000

00000114 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
 114:	e7fe      	b.n	114 <Dummy_Handler>
 116:	46c0      	nop			; (mov r8, r8)

00000118 <Reset_Handler>:
        if (pSrc != pDest) {
 118:	4925      	ldr	r1, [pc, #148]	; (1b0 <Reset_Handler+0x98>)
 11a:	4826      	ldr	r0, [pc, #152]	; (1b4 <Reset_Handler+0x9c>)
{
 11c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
        if (pSrc != pDest) {
 11e:	4281      	cmp	r1, r0
 120:	d009      	beq.n	136 <Reset_Handler+0x1e>
                for (; pDest < &_erelocate;) {
 122:	4b25      	ldr	r3, [pc, #148]	; (1b8 <Reset_Handler+0xa0>)
 124:	4298      	cmp	r0, r3
 126:	d206      	bcs.n	136 <Reset_Handler+0x1e>
                        *pDest++ = *pSrc++;
 128:	43c2      	mvns	r2, r0
 12a:	18d2      	adds	r2, r2, r3
 12c:	0892      	lsrs	r2, r2, #2
 12e:	3201      	adds	r2, #1
 130:	0092      	lsls	r2, r2, #2
 132:	4b22      	ldr	r3, [pc, #136]	; (1bc <Reset_Handler+0xa4>)
 134:	4798      	blx	r3
        for (pDest = &_szero; pDest < &_ezero;) {
 136:	4822      	ldr	r0, [pc, #136]	; (1c0 <Reset_Handler+0xa8>)
 138:	4b22      	ldr	r3, [pc, #136]	; (1c4 <Reset_Handler+0xac>)
 13a:	4298      	cmp	r0, r3
 13c:	d207      	bcs.n	14e <Reset_Handler+0x36>
                *pDest++ = 0;
 13e:	43c2      	mvns	r2, r0
 140:	18d2      	adds	r2, r2, r3
 142:	0892      	lsrs	r2, r2, #2
 144:	3201      	adds	r2, #1
 146:	0092      	lsls	r2, r2, #2
 148:	2100      	movs	r1, #0
 14a:	4b1f      	ldr	r3, [pc, #124]	; (1c8 <Reset_Handler+0xb0>)
 14c:	4798      	blx	r3
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
 14e:	21ff      	movs	r1, #255	; 0xff
 150:	4b1e      	ldr	r3, [pc, #120]	; (1cc <Reset_Handler+0xb4>)
 152:	4a1f      	ldr	r2, [pc, #124]	; (1d0 <Reset_Handler+0xb8>)
 154:	438b      	bics	r3, r1
 156:	6093      	str	r3, [r2, #8]
        SBMATRIX->SFR[SBMATRIX_SLAVE_HMCRAMC0].reg = 2;
 158:	2390      	movs	r3, #144	; 0x90
        USB->DEVICE.QOSCTRL.bit.CQOS = 2;
 15a:	2503      	movs	r5, #3
 15c:	2402      	movs	r4, #2
        USB->DEVICE.QOSCTRL.bit.DQOS = 2;
 15e:	270c      	movs	r7, #12
 160:	2608      	movs	r6, #8
        SBMATRIX->SFR[SBMATRIX_SLAVE_HMCRAMC0].reg = 2;
 162:	4a1c      	ldr	r2, [pc, #112]	; (1d4 <Reset_Handler+0xbc>)
 164:	39fd      	subs	r1, #253	; 0xfd
 166:	005b      	lsls	r3, r3, #1
 168:	50d1      	str	r1, [r2, r3]
        USB->DEVICE.QOSCTRL.bit.CQOS = 2;
 16a:	4a1b      	ldr	r2, [pc, #108]	; (1d8 <Reset_Handler+0xc0>)
 16c:	78d3      	ldrb	r3, [r2, #3]
 16e:	43ab      	bics	r3, r5
 170:	4323      	orrs	r3, r4
 172:	70d3      	strb	r3, [r2, #3]
        USB->DEVICE.QOSCTRL.bit.DQOS = 2;
 174:	78d3      	ldrb	r3, [r2, #3]
 176:	43bb      	bics	r3, r7
 178:	4333      	orrs	r3, r6
 17a:	70d3      	strb	r3, [r2, #3]
        DMAC->QOSCTRL.bit.DQOS = 2;
 17c:	2230      	movs	r2, #48	; 0x30
 17e:	4b17      	ldr	r3, [pc, #92]	; (1dc <Reset_Handler+0xc4>)
 180:	7b98      	ldrb	r0, [r3, #14]
 182:	4390      	bics	r0, r2
 184:	2220      	movs	r2, #32
 186:	4310      	orrs	r0, r2
 188:	7398      	strb	r0, [r3, #14]
        DMAC->QOSCTRL.bit.FQOS = 2;
 18a:	7b99      	ldrb	r1, [r3, #14]
 18c:	43b9      	bics	r1, r7
 18e:	4331      	orrs	r1, r6
 190:	7399      	strb	r1, [r3, #14]
        NVMCTRL->CTRLB.bit.MANW = 1;
 192:	2180      	movs	r1, #128	; 0x80
        DMAC->QOSCTRL.bit.WRBQOS = 2;
 194:	7b9a      	ldrb	r2, [r3, #14]
 196:	43aa      	bics	r2, r5
 198:	4322      	orrs	r2, r4
 19a:	739a      	strb	r2, [r3, #14]
        NVMCTRL->CTRLB.bit.MANW = 1;
 19c:	4a10      	ldr	r2, [pc, #64]	; (1e0 <Reset_Handler+0xc8>)
 19e:	6853      	ldr	r3, [r2, #4]
 1a0:	430b      	orrs	r3, r1
 1a2:	6053      	str	r3, [r2, #4]
        __libc_init_array();
 1a4:	4b0f      	ldr	r3, [pc, #60]	; (1e4 <Reset_Handler+0xcc>)
 1a6:	4798      	blx	r3
        main();
 1a8:	4b0f      	ldr	r3, [pc, #60]	; (1e8 <Reset_Handler+0xd0>)
 1aa:	4798      	blx	r3
 1ac:	e7fe      	b.n	1ac <Reset_Handler+0x94>
 1ae:	46c0      	nop			; (mov r8, r8)
 1b0:	00000e58 	.word	0x00000e58
 1b4:	20000000 	.word	0x20000000
 1b8:	2000000c 	.word	0x2000000c
 1bc:	00000e15 	.word	0x00000e15
 1c0:	20000010 	.word	0x20000010
 1c4:	200001e0 	.word	0x200001e0
 1c8:	00000e27 	.word	0x00000e27
 1cc:	00000000 	.word	0x00000000
 1d0:	e000ed00 	.word	0xe000ed00
 1d4:	41007000 	.word	0x41007000
 1d8:	41005000 	.word	0x41005000
 1dc:	41004800 	.word	0x41004800
 1e0:	41004000 	.word	0x41004000
 1e4:	00000dcd 	.word	0x00000dcd
 1e8:	00000681 	.word	0x00000681

000001ec <SystemInit>:
 1ec:	4a01      	ldr	r2, [pc, #4]	; (1f4 <SystemInit+0x8>)
 1ee:	4b02      	ldr	r3, [pc, #8]	; (1f8 <SystemInit+0xc>)
 1f0:	601a      	str	r2, [r3, #0]
 1f2:	4770      	bx	lr
 1f4:	000f4240 	.word	0x000f4240
 1f8:	20000000 	.word	0x20000000

000001fc <init>:
#include <boardDefines.h>
#include "math.h"



void init() {
 1fc:	b5f0      	push	{r4, r5, r6, r7, lr}
 1fe:	46de      	mov	lr, fp
 200:	4657      	mov	r7, sl
 202:	464e      	mov	r6, r9
 204:	4645      	mov	r5, r8

    /* Set 1 Flash Wait State for 48MHz, cf tables 20.9 and 35.27 in SAMD21 Datasheet */
    NVMCTRL->CTRLB.bit.RWS = NVMCTRL_CTRLB_RWS_HALF_Val;
 206:	211e      	movs	r1, #30
void init() {
 208:	b5e0      	push	{r5, r6, r7, lr}

    /* Turn on the digital interface clock */
    PM->APBAMASK.reg |= PM_APBAMASK_GCLK;
 20a:	2508      	movs	r5, #8
    NVMCTRL->CTRLB.bit.RWS = NVMCTRL_CTRLB_RWS_HALF_Val;
 20c:	4afe      	ldr	r2, [pc, #1016]	; (608 <init+0x40c>)
void init() {
 20e:	b083      	sub	sp, #12
    NVMCTRL->CTRLB.bit.RWS = NVMCTRL_CTRLB_RWS_HALF_Val;
 210:	6853      	ldr	r3, [r2, #4]
 212:	438b      	bics	r3, r1
 214:	391c      	subs	r1, #28
 216:	430b      	orrs	r3, r1
 218:	6053      	str	r3, [r2, #4]
    PM->APBAMASK.reg |= PM_APBAMASK_GCLK;
 21a:	4afc      	ldr	r2, [pc, #1008]	; (60c <init+0x410>)
 21c:	6993      	ldr	r3, [r2, #24]
 21e:	432b      	orrs	r3, r5
 220:	6193      	str	r3, [r2, #24]

    SystemInit();
 222:	4bfb      	ldr	r3, [pc, #1004]	; (610 <init+0x414>)
 224:	4798      	blx	r3
    GclkInit(0);
 226:	2000      	movs	r0, #0
 228:	4bfa      	ldr	r3, [pc, #1000]	; (614 <init+0x418>)
 22a:	4798      	blx	r3
    RtcInit();
 22c:	4bfa      	ldr	r3, [pc, #1000]	; (618 <init+0x41c>)
 22e:	4798      	blx	r3
    delayInit();
 230:	4bfa      	ldr	r3, [pc, #1000]	; (61c <init+0x420>)
 232:	4798      	blx	r3
    adcInit();
 234:	4bfa      	ldr	r3, [pc, #1000]	; (620 <init+0x424>)
 236:	4798      	blx	r3
    PORT->Group[p.group].PINCFG[p.pin].bit.PMUXEN = 0;
 238:	2054      	movs	r0, #84	; 0x54
 23a:	2201      	movs	r2, #1
 23c:	4bf9      	ldr	r3, [pc, #996]	; (624 <init+0x428>)
 23e:	5c19      	ldrb	r1, [r3, r0]
 240:	4391      	bics	r1, r2
 242:	5419      	strb	r1, [r3, r0]
    PORT->Group[p.group].DIRSET.reg = (1<<p.pin);
 244:	2180      	movs	r1, #128	; 0x80
 246:	0349      	lsls	r1, r1, #13
 248:	6099      	str	r1, [r3, #8]
        PORT->Group[p.group].PMUX[p.pin/2].bit.PMUXE = 0x1;
 24a:	2133      	movs	r1, #51	; 0x33
 24c:	4688      	mov	r8, r1
 24e:	2001      	movs	r0, #1
 250:	4646      	mov	r6, r8
 252:	5c5c      	ldrb	r4, [r3, r1]
 254:	3924      	subs	r1, #36	; 0x24
 256:	438c      	bics	r4, r1
 258:	4304      	orrs	r4, r0
 25a:	559c      	strb	r4, [r3, r6]
    PORT->Group[p.group].PINCFG[p.pin].bit.PMUXEN = 1;
 25c:	3613      	adds	r6, #19
 25e:	5d9c      	ldrb	r4, [r3, r6]
 260:	4304      	orrs	r4, r0
 262:	559c      	strb	r4, [r3, r6]
    PORT->Group[p.group].PINCFG[p.pin].bit.PMUXEN = 0;
 264:	3601      	adds	r6, #1
 266:	5d9c      	ldrb	r4, [r3, r6]
 268:	4394      	bics	r4, r2
 26a:	559c      	strb	r4, [r3, r6]
    PORT->Group[p.group].PINCFG[p.pin].bit.INEN = 1;
 26c:	2402      	movs	r4, #2
 26e:	5d9f      	ldrb	r7, [r3, r6]
 270:	4327      	orrs	r7, r4
 272:	559f      	strb	r7, [r3, r6]
    PORT->Group[p.group].DIRCLR.reg = (1<<p.pin);
 274:	2780      	movs	r7, #128	; 0x80
        PORT->Group[p.group].PMUX[p.pin/2].bit.PMUXO = p.mux;
 276:	4644      	mov	r4, r8
    PORT->Group[p.group].DIRCLR.reg = (1<<p.pin);
 278:	605f      	str	r7, [r3, #4]
        PORT->Group[p.group].PMUX[p.pin/2].bit.PMUXO = p.mux;
 27a:	5d1f      	ldrb	r7, [r3, r4]
 27c:	2410      	movs	r4, #16
 27e:	46a4      	mov	ip, r4
 280:	4664      	mov	r4, ip
 282:	400f      	ands	r7, r1
 284:	4327      	orrs	r7, r4
 286:	4644      	mov	r4, r8
 288:	551f      	strb	r7, [r3, r4]
    PORT->Group[p.group].PINCFG[p.pin].bit.PMUXEN = 1;
 28a:	5d9f      	ldrb	r7, [r3, r6]
    PORT->Group[p.group].PINCFG[p.pin].bit.INEN = 1;
 28c:	3c31      	subs	r4, #49	; 0x31
    PORT->Group[p.group].PINCFG[p.pin].bit.PMUXEN = 1;
 28e:	4307      	orrs	r7, r0
 290:	559f      	strb	r7, [r3, r6]
    PORT->Group[p.group].PINCFG[p.pin].bit.PMUXEN = 0;
 292:	367c      	adds	r6, #124	; 0x7c
 294:	5d9f      	ldrb	r7, [r3, r6]
 296:	4397      	bics	r7, r2
 298:	559f      	strb	r7, [r3, r6]
    PORT->Group[p.group].PINCFG[p.pin].bit.INEN = 1;
 29a:	5d9f      	ldrb	r7, [r3, r6]
 29c:	4327      	orrs	r7, r4
 29e:	559f      	strb	r7, [r3, r6]
        PORT->Group[p.group].PMUX[p.pin/2].bit.PMUXO = p.mux;
 2a0:	4667      	mov	r7, ip
    PORT->Group[p.group].DIRCLR.reg = (1<<p.pin);
 2a2:	3482      	adds	r4, #130	; 0x82
 2a4:	511d      	str	r5, [r3, r4]
        PORT->Group[p.group].PMUX[p.pin/2].bit.PMUXO = p.mux;
 2a6:	342d      	adds	r4, #45	; 0x2d
 2a8:	46a3      	mov	fp, r4
 2aa:	5d1c      	ldrb	r4, [r3, r4]
 2ac:	400c      	ands	r4, r1
 2ae:	433c      	orrs	r4, r7
 2b0:	46a0      	mov	r8, r4
 2b2:	465c      	mov	r4, fp
 2b4:	4647      	mov	r7, r8
 2b6:	551f      	strb	r7, [r3, r4]
    PORT->Group[p.group].PINCFG[p.pin].bit.PMUXEN = 1;
 2b8:	5d9c      	ldrb	r4, [r3, r6]
    PORT->Group[p.group].PINCFG[p.pin].bit.INEN = 1;
 2ba:	2702      	movs	r7, #2
    PORT->Group[p.group].PINCFG[p.pin].bit.PMUXEN = 1;
 2bc:	4304      	orrs	r4, r0
 2be:	559c      	strb	r4, [r3, r6]
    PORT->Group[p.group].PINCFG[p.pin].bit.PMUXEN = 0;
 2c0:	24d7      	movs	r4, #215	; 0xd7
 2c2:	5d1e      	ldrb	r6, [r3, r4]
 2c4:	4396      	bics	r6, r2
 2c6:	551e      	strb	r6, [r3, r4]
    PORT->Group[p.group].DIRSET.reg = (1<<p.pin);
 2c8:	2680      	movs	r6, #128	; 0x80
 2ca:	3c4f      	subs	r4, #79	; 0x4f
 2cc:	0436      	lsls	r6, r6, #16
 2ce:	511e      	str	r6, [r3, r4]
 2d0:	46a2      	mov	sl, r4
}


inline static void pinLow(Pin p) {
    PORT->Group[p.group].OUTCLR.reg = (1<<p.pin);
 2d2:	340c      	adds	r4, #12
 2d4:	511e      	str	r6, [r3, r4]
    PORT->Group[p.group].PINCFG[p.pin].bit.PMUXEN = 0;
 2d6:	26c2      	movs	r6, #194	; 0xc2
    PORT->Group[p.group].OUTCLR.reg = (1<<p.pin);
 2d8:	46a1      	mov	r9, r4
    PORT->Group[p.group].PINCFG[p.pin].bit.PMUXEN = 0;
 2da:	5d9c      	ldrb	r4, [r3, r6]
 2dc:	4394      	bics	r4, r2
 2de:	559c      	strb	r4, [r3, r6]
    PORT->Group[p.group].PINCFG[p.pin].bit.INEN = 1;
 2e0:	5d9c      	ldrb	r4, [r3, r6]
 2e2:	433c      	orrs	r4, r7
 2e4:	559c      	strb	r4, [r3, r6]
    PORT->Group[p.group].DIRCLR.reg = (1<<p.pin);
 2e6:	2404      	movs	r4, #4
 2e8:	3782      	adds	r7, #130	; 0x82
 2ea:	51dc      	str	r4, [r3, r7]
 2ec:	46a0      	mov	r8, r4
        PORT->Group[p.group].PMUX[p.pin/2].bit.PMUXE = p.mux;
 2ee:	465c      	mov	r4, fp
 2f0:	5d1f      	ldrb	r7, [r3, r4]
 2f2:	438f      	bics	r7, r1
 2f4:	4307      	orrs	r7, r0
 2f6:	551f      	strb	r7, [r3, r4]
    PORT->Group[p.group].DIRSET.reg = (1<<p.pin);
 2f8:	2480      	movs	r4, #128	; 0x80
    PORT->Group[p.group].PINCFG[p.pin].bit.PMUXEN = 1;
 2fa:	5d9f      	ldrb	r7, [r3, r6]
    PORT->Group[p.group].DIRSET.reg = (1<<p.pin);
 2fc:	03e4      	lsls	r4, r4, #15
    PORT->Group[p.group].PINCFG[p.pin].bit.PMUXEN = 1;
 2fe:	4307      	orrs	r7, r0
 300:	559f      	strb	r7, [r3, r6]
    PORT->Group[p.group].PINCFG[p.pin].bit.PMUXEN = 0;
 302:	27d6      	movs	r7, #214	; 0xd6
    PORT->Group[p.group].DIRSET.reg = (1<<p.pin);
 304:	46a3      	mov	fp, r4
    PORT->Group[p.group].PINCFG[p.pin].bit.PMUXEN = 0;
 306:	5dde      	ldrb	r6, [r3, r7]
    PORT->Group[p.group].DIRSET.reg = (1<<p.pin);
 308:	4654      	mov	r4, sl
    PORT->Group[p.group].PINCFG[p.pin].bit.PMUXEN = 0;
 30a:	4396      	bics	r6, r2
 30c:	55de      	strb	r6, [r3, r7]
    PORT->Group[p.group].DIRSET.reg = (1<<p.pin);
 30e:	465e      	mov	r6, fp
 310:	511e      	str	r6, [r3, r4]
    PORT->Group[p.group].OUTCLR.reg = (1<<p.pin);
 312:	464c      	mov	r4, r9
 314:	511e      	str	r6, [r3, r4]
    PORT->Group[p.group].PINCFG[p.pin].bit.PMUXEN = 0;
 316:	2643      	movs	r6, #67	; 0x43
 318:	5d9f      	ldrb	r7, [r3, r6]
    PORT->Group[p.group].PINCFG[p.pin].bit.INEN = 1;
 31a:	3c92      	subs	r4, #146	; 0x92
    PORT->Group[p.group].PINCFG[p.pin].bit.PMUXEN = 0;
 31c:	4397      	bics	r7, r2
 31e:	559f      	strb	r7, [r3, r6]
    PORT->Group[p.group].PINCFG[p.pin].bit.INEN = 1;
 320:	5d9f      	ldrb	r7, [r3, r6]
 322:	4327      	orrs	r7, r4
 324:	559f      	strb	r7, [r3, r6]
        PORT->Group[p.group].PMUX[p.pin/2].bit.PMUXO = p.mux;
 326:	2731      	movs	r7, #49	; 0x31
 328:	4664      	mov	r4, ip
    PORT->Group[p.group].DIRCLR.reg = (1<<p.pin);
 32a:	605d      	str	r5, [r3, #4]
        PORT->Group[p.group].PMUX[p.pin/2].bit.PMUXO = p.mux;
 32c:	5ddd      	ldrb	r5, [r3, r7]
 32e:	400d      	ands	r5, r1
 330:	4325      	orrs	r5, r4
 332:	55dd      	strb	r5, [r3, r7]
    PORT->Group[p.group].PINCFG[p.pin].bit.PMUXEN = 1;
 334:	5d9d      	ldrb	r5, [r3, r6]
    PORT->Group[p.group].PINCFG[p.pin].bit.INEN = 1;
 336:	2402      	movs	r4, #2
    PORT->Group[p.group].PINCFG[p.pin].bit.PMUXEN = 1;
 338:	4305      	orrs	r5, r0
 33a:	559d      	strb	r5, [r3, r6]
    PORT->Group[p.group].PINCFG[p.pin].bit.PMUXEN = 0;
 33c:	3616      	adds	r6, #22
 33e:	5d9d      	ldrb	r5, [r3, r6]
 340:	4395      	bics	r5, r2
 342:	559d      	strb	r5, [r3, r6]
    PORT->Group[p.group].DIRSET.reg = (1<<p.pin);
 344:	2580      	movs	r5, #128	; 0x80
 346:	04ad      	lsls	r5, r5, #18
 348:	609d      	str	r5, [r3, #8]
    PORT->Group[p.group].OUTCLR.reg = (1<<p.pin);
 34a:	615d      	str	r5, [r3, #20]
    PORT->Group[p.group].PINCFG[p.pin].bit.PMUXEN = 0;
 34c:	2542      	movs	r5, #66	; 0x42
 34e:	5d5e      	ldrb	r6, [r3, r5]
 350:	4396      	bics	r6, r2
 352:	555e      	strb	r6, [r3, r5]
    PORT->Group[p.group].PINCFG[p.pin].bit.INEN = 1;
 354:	5d5e      	ldrb	r6, [r3, r5]
 356:	4326      	orrs	r6, r4
    PORT->Group[p.group].DIRCLR.reg = (1<<p.pin);
 358:	4644      	mov	r4, r8
    PORT->Group[p.group].PINCFG[p.pin].bit.INEN = 1;
 35a:	555e      	strb	r6, [r3, r5]
    PORT->Group[p.group].DIRCLR.reg = (1<<p.pin);
 35c:	605c      	str	r4, [r3, #4]
        PORT->Group[p.group].PMUX[p.pin/2].bit.PMUXE = p.mux;
 35e:	5dde      	ldrb	r6, [r3, r7]
    PORT->Group[p.group].PINCFG[p.pin].bit.PMUXEN = 0;
 360:	3444      	adds	r4, #68	; 0x44
        PORT->Group[p.group].PMUX[p.pin/2].bit.PMUXE = p.mux;
 362:	438e      	bics	r6, r1
 364:	4306      	orrs	r6, r0
 366:	55de      	strb	r6, [r3, r7]
    PORT->Group[p.group].PINCFG[p.pin].bit.PMUXEN = 1;
 368:	5d5e      	ldrb	r6, [r3, r5]
    PORT->Group[p.group].PINCFG[p.pin].bit.PMUXEN = 0;
 36a:	46a0      	mov	r8, r4
    PORT->Group[p.group].PINCFG[p.pin].bit.PMUXEN = 1;
 36c:	4306      	orrs	r6, r0
 36e:	555e      	strb	r6, [r3, r5]
    PORT->Group[p.group].PINCFG[p.pin].bit.PMUXEN = 0;
 370:	2658      	movs	r6, #88	; 0x58
 372:	5d9d      	ldrb	r5, [r3, r6]
 374:	371a      	adds	r7, #26
 376:	4395      	bics	r5, r2
 378:	559d      	strb	r5, [r3, r6]
    PORT->Group[p.group].DIRSET.reg = (1<<p.pin);
 37a:	2580      	movs	r5, #128	; 0x80
 37c:	046d      	lsls	r5, r5, #17
 37e:	609d      	str	r5, [r3, #8]
    PORT->Group[p.group].OUTCLR.reg = (1<<p.pin);
 380:	615d      	str	r5, [r3, #20]
    pinIn(senseDPin);
    pinMux(senseDPin);
    pinOut(fireDPin);
    pinLow(fireDPin);

    charges.igniterAHot = false;
 382:	2500      	movs	r5, #0
 384:	4ea8      	ldr	r6, [pc, #672]	; (628 <init+0x42c>)
 386:	7035      	strb	r5, [r6, #0]
    charges.igniterBHot = false;
 388:	7235      	strb	r5, [r6, #8]
    charges.igniterCHot = false;
 38a:	7435      	strb	r5, [r6, #16]
    charges.igniterDHot = false;
 38c:	7635      	strb	r5, [r6, #24]
    PORT->Group[p.group].PINCFG[p.pin].bit.PMUXEN = 0;
 38e:	5d1e      	ldrb	r6, [r3, r4]
 390:	4396      	bics	r6, r2
 392:	551e      	strb	r6, [r3, r4]
    PORT->Group[p.group].DIRSET.reg = (1<<p.pin);
 394:	2680      	movs	r6, #128	; 0x80
 396:	0076      	lsls	r6, r6, #1
 398:	609e      	str	r6, [r3, #8]
    PORT->Group[p.group].PINCFG[p.pin].bit.PMUXEN = 0;
 39a:	3401      	adds	r4, #1
 39c:	5d1e      	ldrb	r6, [r3, r4]
 39e:	46a1      	mov	r9, r4
 3a0:	4396      	bics	r6, r2
 3a2:	551e      	strb	r6, [r3, r4]
    PORT->Group[p.group].DIRSET.reg = (1<<p.pin);
 3a4:	2680      	movs	r6, #128	; 0x80
 3a6:	00b6      	lsls	r6, r6, #2
 3a8:	609e      	str	r6, [r3, #8]
    PORT->Group[p.group].PINCFG[p.pin].bit.PMUXEN = 0;
 3aa:	5dde      	ldrb	r6, [r3, r7]
    PORT->Group[p.group].PINCFG[p.pin].bit.INEN = 1;
 3ac:	3c47      	subs	r4, #71	; 0x47
    PORT->Group[p.group].PINCFG[p.pin].bit.PMUXEN = 0;
 3ae:	4396      	bics	r6, r2
 3b0:	55de      	strb	r6, [r3, r7]
    PORT->Group[p.group].PINCFG[p.pin].bit.INEN = 1;
 3b2:	5dde      	ldrb	r6, [r3, r7]
 3b4:	4326      	orrs	r6, r4
 3b6:	55de      	strb	r6, [r3, r7]
    PORT->Group[p.group].DIRCLR.reg = (1<<p.pin);
 3b8:	2680      	movs	r6, #128	; 0x80
 3ba:	0136      	lsls	r6, r6, #4
 3bc:	605e      	str	r6, [r3, #4]
        PORT->Group[p.group].PMUX[p.pin/2].bit.PMUXO = p.mux;
 3be:	3433      	adds	r4, #51	; 0x33
 3c0:	5d1e      	ldrb	r6, [r3, r4]
 3c2:	400e      	ands	r6, r1
 3c4:	0034      	movs	r4, r6
 3c6:	2620      	movs	r6, #32
 3c8:	4334      	orrs	r4, r6
 3ca:	46a4      	mov	ip, r4
 3cc:	2435      	movs	r4, #53	; 0x35
 3ce:	4666      	mov	r6, ip
 3d0:	551e      	strb	r6, [r3, r4]
    PORT->Group[p.group].PINCFG[p.pin].bit.PMUXEN = 1;
 3d2:	5ddc      	ldrb	r4, [r3, r7]
 3d4:	4304      	orrs	r4, r0
 3d6:	55dc      	strb	r4, [r3, r7]
        PORT->Group[p.group].PMUX[p.pin/2].bit.PMUXO = p.mux;
 3d8:	2434      	movs	r4, #52	; 0x34
 3da:	46a4      	mov	ip, r4
 3dc:	5d1f      	ldrb	r7, [r3, r4]
 3de:	3c14      	subs	r4, #20
 3e0:	400f      	ands	r7, r1
 3e2:	4327      	orrs	r7, r4
 3e4:	4664      	mov	r4, ip
 3e6:	551f      	strb	r7, [r3, r4]
    PORT->Group[p.group].PINCFG[p.pin].bit.PMUXEN = 1;
 3e8:	464c      	mov	r4, r9
 3ea:	5d1f      	ldrb	r7, [r3, r4]
 3ec:	4307      	orrs	r7, r0
 3ee:	551f      	strb	r7, [r3, r4]
        PORT->Group[p.group].PMUX[p.pin/2].bit.PMUXE = p.mux;
 3f0:	4664      	mov	r4, ip
 3f2:	5d1f      	ldrb	r7, [r3, r4]
 3f4:	3c32      	subs	r4, #50	; 0x32
 3f6:	438f      	bics	r7, r1
 3f8:	4327      	orrs	r7, r4
 3fa:	4664      	mov	r4, ip
 3fc:	551f      	strb	r7, [r3, r4]
    PORT->Group[p.group].PINCFG[p.pin].bit.PMUXEN = 1;
 3fe:	4644      	mov	r4, r8
 400:	5d1f      	ldrb	r7, [r3, r4]
 402:	4307      	orrs	r7, r0
 404:	551f      	strb	r7, [r3, r4]
    PORT->Group[p.group].PINCFG[p.pin].bit.PMUXEN = 0;
 406:	3482      	adds	r4, #130	; 0x82
 408:	5d1f      	ldrb	r7, [r3, r4]
 40a:	4397      	bics	r7, r2
 40c:	551f      	strb	r7, [r3, r4]
    PORT->Group[p.group].DIRSET.reg = (1<<p.pin);
 40e:	2780      	movs	r7, #128	; 0x80
 410:	4654      	mov	r4, sl
 412:	00ff      	lsls	r7, r7, #3
 414:	511f      	str	r7, [r3, r4]
    PORT->Group[p.group].OUTSET.reg = (1<<p.pin);
 416:	3410      	adds	r4, #16
 418:	511f      	str	r7, [r3, r4]
    PORT->Group[p.group].PINCFG[p.pin].bit.PMUXEN = 0;
 41a:	3c4e      	subs	r4, #78	; 0x4e
 41c:	46a0      	mov	r8, r4
 41e:	5d1c      	ldrb	r4, [r3, r4]
 420:	4394      	bics	r4, r2
 422:	46a4      	mov	ip, r4
 424:	4644      	mov	r4, r8
 426:	4666      	mov	r6, ip
 428:	551e      	strb	r6, [r3, r4]
    PORT->Group[p.group].DIRSET.reg = (1<<p.pin);
 42a:	609f      	str	r7, [r3, #8]
    PORT->Group[p.group].PINCFG[p.pin].bit.PMUXEN = 0;
 42c:	3406      	adds	r4, #6
    PORT->Group[p.group].OUTSET.reg = (1<<p.pin);
 42e:	619f      	str	r7, [r3, #24]
    PORT->Group[p.group].PINCFG[p.pin].bit.PMUXEN = 0;
 430:	5d1f      	ldrb	r7, [r3, r4]
 432:	46a0      	mov	r8, r4
 434:	4397      	bics	r7, r2
 436:	551f      	strb	r7, [r3, r4]
    PORT->Group[p.group].DIRSET.reg = (1<<p.pin);
 438:	2780      	movs	r7, #128	; 0x80
 43a:	027f      	lsls	r7, r7, #9
 43c:	609f      	str	r7, [r3, #8]
    PORT->Group[p.group].PINCFG[p.pin].bit.PMUXEN = 0;
 43e:	3401      	adds	r4, #1
 440:	5d1f      	ldrb	r7, [r3, r4]
    PORT->Group[p.group].PINCFG[p.pin].bit.INEN = 1;
 442:	2602      	movs	r6, #2
    PORT->Group[p.group].PINCFG[p.pin].bit.PMUXEN = 0;
 444:	4397      	bics	r7, r2
 446:	551f      	strb	r7, [r3, r4]
    PORT->Group[p.group].DIRSET.reg = (1<<p.pin);
 448:	2780      	movs	r7, #128	; 0x80
 44a:	02bf      	lsls	r7, r7, #10
 44c:	609f      	str	r7, [r3, #8]
    PORT->Group[p.group].PINCFG[p.pin].bit.PMUXEN = 0;
 44e:	2753      	movs	r7, #83	; 0x53
 450:	46a1      	mov	r9, r4
 452:	5ddc      	ldrb	r4, [r3, r7]
 454:	4394      	bics	r4, r2
 456:	55dc      	strb	r4, [r3, r7]
    PORT->Group[p.group].PINCFG[p.pin].bit.INEN = 1;
 458:	5ddc      	ldrb	r4, [r3, r7]
 45a:	4334      	orrs	r4, r6
 45c:	55dc      	strb	r4, [r3, r7]
    PORT->Group[p.group].DIRCLR.reg = (1<<p.pin);
 45e:	2480      	movs	r4, #128	; 0x80
 460:	0324      	lsls	r4, r4, #12
 462:	605c      	str	r4, [r3, #4]
        PORT->Group[p.group].PMUX[p.pin/2].bit.PMUXO = p.mux;
 464:	2439      	movs	r4, #57	; 0x39
 466:	46a2      	mov	sl, r4
 468:	5d1c      	ldrb	r4, [r3, r4]
 46a:	361e      	adds	r6, #30
 46c:	400c      	ands	r4, r1
 46e:	4334      	orrs	r4, r6
 470:	46a4      	mov	ip, r4
 472:	4654      	mov	r4, sl
 474:	4666      	mov	r6, ip
 476:	551e      	strb	r6, [r3, r4]
    PORT->Group[p.group].PINCFG[p.pin].bit.PMUXEN = 1;
 478:	5ddc      	ldrb	r4, [r3, r7]
    PORT->Group[p.group].PINCFG[p.pin].bit.INEN = 1;
 47a:	2602      	movs	r6, #2
    PORT->Group[p.group].PINCFG[p.pin].bit.PMUXEN = 1;
 47c:	4304      	orrs	r4, r0
 47e:	55dc      	strb	r4, [r3, r7]
        PORT->Group[p.group].PMUX[p.pin/2].bit.PMUXO = p.mux;
 480:	2438      	movs	r4, #56	; 0x38
 482:	46a4      	mov	ip, r4
 484:	5d1f      	ldrb	r7, [r3, r4]
 486:	3c18      	subs	r4, #24
 488:	400f      	ands	r7, r1
 48a:	4327      	orrs	r7, r4
 48c:	4664      	mov	r4, ip
 48e:	551f      	strb	r7, [r3, r4]
    PORT->Group[p.group].PINCFG[p.pin].bit.PMUXEN = 1;
 490:	464c      	mov	r4, r9
 492:	5d1f      	ldrb	r7, [r3, r4]
 494:	4307      	orrs	r7, r0
 496:	551f      	strb	r7, [r3, r4]
        PORT->Group[p.group].PMUX[p.pin/2].bit.PMUXE = p.mux;
 498:	4664      	mov	r4, ip
 49a:	5d1f      	ldrb	r7, [r3, r4]
 49c:	3c36      	subs	r4, #54	; 0x36
 49e:	438f      	bics	r7, r1
 4a0:	4327      	orrs	r7, r4
 4a2:	4664      	mov	r4, ip
 4a4:	551f      	strb	r7, [r3, r4]
    PORT->Group[p.group].PINCFG[p.pin].bit.PMUXEN = 1;
 4a6:	4644      	mov	r4, r8
 4a8:	5d1f      	ldrb	r7, [r3, r4]
 4aa:	4307      	orrs	r7, r0
 4ac:	551f      	strb	r7, [r3, r4]
    PORT->Group[p.group].PINCFG[p.pin].bit.PMUXEN = 0;
 4ae:	3402      	adds	r4, #2
 4b0:	5d1f      	ldrb	r7, [r3, r4]
 4b2:	4397      	bics	r7, r2
 4b4:	551f      	strb	r7, [r3, r4]
    PORT->Group[p.group].DIRSET.reg = (1<<p.pin);
 4b6:	2780      	movs	r7, #128	; 0x80
 4b8:	02ff      	lsls	r7, r7, #11
    PORT->Group[p.group].PINCFG[p.pin].bit.PMUXEN = 0;
 4ba:	3c06      	subs	r4, #6
    PORT->Group[p.group].DIRSET.reg = (1<<p.pin);
 4bc:	609f      	str	r7, [r3, #8]
    PORT->Group[p.group].OUTSET.reg = (1<<p.pin);
 4be:	619f      	str	r7, [r3, #24]
    PORT->Group[p.group].PINCFG[p.pin].bit.PMUXEN = 0;
 4c0:	5d1f      	ldrb	r7, [r3, r4]
 4c2:	46a4      	mov	ip, r4
 4c4:	4397      	bics	r7, r2
 4c6:	551f      	strb	r7, [r3, r4]
    PORT->Group[p.group].DIRSET.reg = (1<<p.pin);
 4c8:	2780      	movs	r7, #128	; 0x80
 4ca:	017f      	lsls	r7, r7, #5
 4cc:	609f      	str	r7, [r3, #8]
    PORT->Group[p.group].PINCFG[p.pin].bit.PMUXEN = 0;
 4ce:	3403      	adds	r4, #3
 4d0:	5d1f      	ldrb	r7, [r3, r4]
 4d2:	46a1      	mov	r9, r4
 4d4:	4397      	bics	r7, r2
 4d6:	551f      	strb	r7, [r3, r4]
    PORT->Group[p.group].DIRSET.reg = (1<<p.pin);
 4d8:	2780      	movs	r7, #128	; 0x80
 4da:	023f      	lsls	r7, r7, #8
 4dc:	609f      	str	r7, [r3, #8]
    PORT->Group[p.group].PINCFG[p.pin].bit.PMUXEN = 0;
 4de:	274d      	movs	r7, #77	; 0x4d
 4e0:	5ddc      	ldrb	r4, [r3, r7]
 4e2:	4394      	bics	r4, r2
 4e4:	55dc      	strb	r4, [r3, r7]
    PORT->Group[p.group].PINCFG[p.pin].bit.INEN = 1;
 4e6:	5ddc      	ldrb	r4, [r3, r7]
 4e8:	4334      	orrs	r4, r6
 4ea:	55dc      	strb	r4, [r3, r7]
    PORT->Group[p.group].DIRCLR.reg = (1<<p.pin);
 4ec:	2480      	movs	r4, #128	; 0x80
 4ee:	01a4      	lsls	r4, r4, #6
 4f0:	605c      	str	r4, [r3, #4]
        PORT->Group[p.group].PMUX[p.pin/2].bit.PMUXO = p.mux;
 4f2:	2436      	movs	r4, #54	; 0x36
 4f4:	46a0      	mov	r8, r4
 4f6:	5d1c      	ldrb	r4, [r3, r4]
 4f8:	361e      	adds	r6, #30
 4fa:	400c      	ands	r4, r1
 4fc:	4334      	orrs	r4, r6
 4fe:	46a2      	mov	sl, r4
 500:	4644      	mov	r4, r8
 502:	4656      	mov	r6, sl
 504:	551e      	strb	r6, [r3, r4]
    PORT->Group[p.group].PINCFG[p.pin].bit.PMUXEN = 1;
 506:	5ddc      	ldrb	r4, [r3, r7]
 508:	4304      	orrs	r4, r0
 50a:	55dc      	strb	r4, [r3, r7]
        PORT->Group[p.group].PMUX[p.pin/2].bit.PMUXO = p.mux;
 50c:	2437      	movs	r4, #55	; 0x37
 50e:	46a2      	mov	sl, r4
 510:	5d1f      	ldrb	r7, [r3, r4]
 512:	3c17      	subs	r4, #23
 514:	400f      	ands	r7, r1
 516:	4327      	orrs	r7, r4
 518:	4654      	mov	r4, sl
 51a:	551f      	strb	r7, [r3, r4]
    PORT->Group[p.group].PINCFG[p.pin].bit.PMUXEN = 1;
 51c:	464c      	mov	r4, r9
 51e:	5d1f      	ldrb	r7, [r3, r4]
 520:	4307      	orrs	r7, r0
 522:	551f      	strb	r7, [r3, r4]
        PORT->Group[p.group].PMUX[p.pin/2].bit.PMUXE = p.mux;
 524:	4644      	mov	r4, r8
 526:	5d1f      	ldrb	r7, [r3, r4]
 528:	3c34      	subs	r4, #52	; 0x34
 52a:	438f      	bics	r7, r1
 52c:	4327      	orrs	r7, r4
 52e:	4644      	mov	r4, r8
 530:	551f      	strb	r7, [r3, r4]
    PORT->Group[p.group].PINCFG[p.pin].bit.PMUXEN = 1;
 532:	4664      	mov	r4, ip
 534:	5d1f      	ldrb	r7, [r3, r4]
 536:	4307      	orrs	r7, r0
 538:	551f      	strb	r7, [r3, r4]
    PORT->Group[p.group].PINCFG[p.pin].bit.PMUXEN = 0;
 53a:	3402      	adds	r4, #2
 53c:	5d1f      	ldrb	r7, [r3, r4]
 53e:	4397      	bics	r7, r2
 540:	551f      	strb	r7, [r3, r4]
    PORT->Group[p.group].DIRSET.reg = (1<<p.pin);
 542:	2780      	movs	r7, #128	; 0x80
 544:	01ff      	lsls	r7, r7, #7
 546:	609f      	str	r7, [r3, #8]
    PORT->Group[p.group].OUTSET.reg = (1<<p.pin);
 548:	619f      	str	r7, [r3, #24]
    PORT->Group[p.group].PINCFG[p.pin].bit.PMUXEN = 0;
 54a:	2755      	movs	r7, #85	; 0x55
 54c:	5ddc      	ldrb	r4, [r3, r7]
 54e:	4394      	bics	r4, r2
 550:	55dc      	strb	r4, [r3, r7]
    PORT->Group[p.group].DIRSET.reg = (1<<p.pin);
 552:	2480      	movs	r4, #128	; 0x80
 554:	03a4      	lsls	r4, r4, #14
 556:	609c      	str	r4, [r3, #8]
    PORT->Group[p.group].PINCFG[p.pin].bit.PMUXEN = 0;
 558:	5ddc      	ldrb	r4, [r3, r7]
 55a:	4394      	bics	r4, r2
 55c:	55dc      	strb	r4, [r3, r7]
    PORT->Group[p.group].PINCFG[p.pin].bit.DRVSTR = 1;
 55e:	5ddc      	ldrb	r4, [r3, r7]
 560:	46a4      	mov	ip, r4
 562:	2440      	movs	r4, #64	; 0x40
 564:	46a0      	mov	r8, r4
 566:	4664      	mov	r4, ip
 568:	4646      	mov	r6, r8
 56a:	4334      	orrs	r4, r6
 56c:	55dc      	strb	r4, [r3, r7]
    PORT->Group[p.group].PINCFG[p.pin].bit.PMUXEN = 0;
 56e:	2456      	movs	r4, #86	; 0x56
 570:	5d1f      	ldrb	r7, [r3, r4]
 572:	46a0      	mov	r8, r4
 574:	4397      	bics	r7, r2
 576:	551f      	strb	r7, [r3, r4]
    PORT->Group[p.group].DIRSET.reg = (1<<p.pin);
 578:	465c      	mov	r4, fp
 57a:	609c      	str	r4, [r3, #8]
        PORT->Group[p.group].PMUX[p.pin/2].bit.PMUXE = p.mux;
 57c:	243b      	movs	r4, #59	; 0x3b
 57e:	46a4      	mov	ip, r4
 580:	5d1f      	ldrb	r7, [r3, r4]
 582:	3c39      	subs	r4, #57	; 0x39
 584:	438f      	bics	r7, r1
 586:	4327      	orrs	r7, r4
 588:	4664      	mov	r4, ip
 58a:	551f      	strb	r7, [r3, r4]
    PORT->Group[p.group].PINCFG[p.pin].bit.PMUXEN = 1;
 58c:	4644      	mov	r4, r8
 58e:	5d1f      	ldrb	r7, [r3, r4]
        PORT->Group[p.group].PMUX[p.pin/2].bit.PMUXO = p.mux;
 590:	2620      	movs	r6, #32
    PORT->Group[p.group].PINCFG[p.pin].bit.PMUXEN = 1;
 592:	4307      	orrs	r7, r0
 594:	551f      	strb	r7, [r3, r4]
    PORT->Group[p.group].PINCFG[p.pin].bit.PMUXEN = 0;
 596:	2757      	movs	r7, #87	; 0x57
 598:	5ddc      	ldrb	r4, [r3, r7]
 59a:	4394      	bics	r4, r2
 59c:	55dc      	strb	r4, [r3, r7]
    PORT->Group[p.group].PINCFG[p.pin].bit.INEN = 1;
 59e:	2402      	movs	r4, #2
 5a0:	5dda      	ldrb	r2, [r3, r7]
 5a2:	4314      	orrs	r4, r2
    PORT->Group[p.group].DIRCLR.reg = (1<<p.pin);
 5a4:	2280      	movs	r2, #128	; 0x80
 5a6:	0412      	lsls	r2, r2, #16
    PORT->Group[p.group].PINCFG[p.pin].bit.INEN = 1;
 5a8:	55dc      	strb	r4, [r3, r7]
    PORT->Group[p.group].DIRCLR.reg = (1<<p.pin);
 5aa:	605a      	str	r2, [r3, #4]
        PORT->Group[p.group].PMUX[p.pin/2].bit.PMUXO = p.mux;
 5ac:	4662      	mov	r2, ip
 5ae:	5c9a      	ldrb	r2, [r3, r2]
 5b0:	4011      	ands	r1, r2
 5b2:	4662      	mov	r2, ip
 5b4:	430e      	orrs	r6, r1
 5b6:	549e      	strb	r6, [r3, r2]
    PORT->Group[p.group].PINCFG[p.pin].bit.PMUXEN = 1;
 5b8:	5dda      	ldrb	r2, [r3, r7]
 5ba:	4310      	orrs	r0, r2
 5bc:	55d8      	strb	r0, [r3, r7]
    pinOut(TxPo);
    pinMux(TxPo);
    pinIn(RxPo);
    pinMux(RxPo);

    delay_ms(200);
 5be:	4b1b      	ldr	r3, [pc, #108]	; (62c <init+0x430>)
 5c0:	20c8      	movs	r0, #200	; 0xc8
 5c2:	4798      	blx	r3

    sercomClockEnable(SPI2, 3, 4);
 5c4:	4c1a      	ldr	r4, [pc, #104]	; (630 <init+0x434>)
 5c6:	2204      	movs	r2, #4
 5c8:	2103      	movs	r1, #3
 5ca:	2002      	movs	r0, #2
 5cc:	47a0      	blx	r4
    sercomSpiMasterInit(SPI2, 1, 3, 0, 0, 0x00);
 5ce:	4e19      	ldr	r6, [pc, #100]	; (634 <init+0x438>)
 5d0:	2300      	movs	r3, #0
 5d2:	9501      	str	r5, [sp, #4]
 5d4:	9500      	str	r5, [sp, #0]
 5d6:	2203      	movs	r2, #3
 5d8:	2101      	movs	r1, #1
 5da:	2002      	movs	r0, #2
 5dc:	47b0      	blx	r6

    sercomClockEnable(SPI0, 3, 4);
 5de:	2204      	movs	r2, #4
 5e0:	2103      	movs	r1, #3
 5e2:	2000      	movs	r0, #0
 5e4:	47a0      	blx	r4
    sercomSpiMasterInit(SPI0, 3, 0, 0, 0, 0x00);
 5e6:	2300      	movs	r3, #0
 5e8:	9501      	str	r5, [sp, #4]
 5ea:	9500      	str	r5, [sp, #0]
 5ec:	2200      	movs	r2, #0
 5ee:	2103      	movs	r1, #3
 5f0:	2000      	movs	r0, #0
 5f2:	47b0      	blx	r6

    sercomClockEnable(SPI1, 3, 4);
 5f4:	2204      	movs	r2, #4
 5f6:	2103      	movs	r1, #3
 5f8:	2001      	movs	r0, #1
 5fa:	47a0      	blx	r4
    sercomSpiMasterInit(SPI1, 3, 0, 0, 0, 0x00);
 5fc:	2300      	movs	r3, #0
 5fe:	9501      	str	r5, [sp, #4]
 600:	9500      	str	r5, [sp, #0]
 602:	2200      	movs	r2, #0
 604:	e018      	b.n	638 <init+0x43c>
 606:	46c0      	nop			; (mov r8, r8)
 608:	41004000 	.word	0x41004000
 60c:	40000400 	.word	0x40000400
 610:	000001ed 	.word	0x000001ed
 614:	00000785 	.word	0x00000785
 618:	00000845 	.word	0x00000845
 61c:	00000945 	.word	0x00000945
 620:	000006ed 	.word	0x000006ed
 624:	41004400 	.word	0x41004400
 628:	200001bc 	.word	0x200001bc
 62c:	00000975 	.word	0x00000975
 630:	00000b09 	.word	0x00000b09
 634:	00000b51 	.word	0x00000b51
 638:	2103      	movs	r1, #3
 63a:	2001      	movs	r0, #1
 63c:	47b0      	blx	r6

    sercomClockEnable(USART3, 4, 8);
 63e:	2208      	movs	r2, #8
 640:	2104      	movs	r1, #4
 642:	2003      	movs	r0, #3
 644:	47a0      	blx	r4
    sercomUartInit(USART3,1,0,19200);
 646:	2396      	movs	r3, #150	; 0x96
 648:	2200      	movs	r2, #0
 64a:	2101      	movs	r1, #1
 64c:	2003      	movs	r0, #3
 64e:	01db      	lsls	r3, r3, #7
 650:	4c07      	ldr	r4, [pc, #28]	; (670 <init+0x474>)
 652:	47a0      	blx	r4

    TC4Init();
 654:	4b07      	ldr	r3, [pc, #28]	; (674 <init+0x478>)
 656:	4798      	blx	r3
    TC5Init();
 658:	4b07      	ldr	r3, [pc, #28]	; (678 <init+0x47c>)
 65a:	4798      	blx	r3
	buzzerInit();
 65c:	4b07      	ldr	r3, [pc, #28]	; (67c <init+0x480>)
 65e:	4798      	blx	r3
}
 660:	b003      	add	sp, #12
 662:	bc3c      	pop	{r2, r3, r4, r5}
 664:	4690      	mov	r8, r2
 666:	4699      	mov	r9, r3
 668:	46a2      	mov	sl, r4
 66a:	46ab      	mov	fp, r5
 66c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 66e:	46c0      	nop			; (mov r8, r8)
 670:	00000bad 	.word	0x00000bad
 674:	000009fd 	.word	0x000009fd
 678:	00000aa1 	.word	0x00000aa1
 67c:	00000841 	.word	0x00000841

00000680 <main>:


int main(void) {
 680:	b570      	push	{r4, r5, r6, lr}

    init();
 682:	4b0d      	ldr	r3, [pc, #52]	; (6b8 <main+0x38>)
 684:	4798      	blx	r3
    //delay_ms(500);

    //continuityBeep();
    //delay_ms(1000);

    startupTick = millis();
 686:	4b0d      	ldr	r3, [pc, #52]	; (6bc <main+0x3c>)
 688:	4798      	blx	r3
 68a:	4b0d      	ldr	r3, [pc, #52]	; (6c0 <main+0x40>)
	
	setBuzzerFreq(1000);
 68c:	4c0d      	ldr	r4, [pc, #52]	; (6c4 <main+0x44>)
    startupTick = millis();
 68e:	6018      	str	r0, [r3, #0]
	setBuzzerFreq(1000);
 690:	20fa      	movs	r0, #250	; 0xfa
 692:	0080      	lsls	r0, r0, #2
 694:	47a0      	blx	r4
			startBuzzing();
 696:	4b0c      	ldr	r3, [pc, #48]	; (6c8 <main+0x48>)
 698:	4798      	blx	r3
 69a:	4d0c      	ldr	r5, [pc, #48]	; (6cc <main+0x4c>)


    while (1) {
		
		setBuzzerFreq(300);
 69c:	2096      	movs	r0, #150	; 0x96
 69e:	0040      	lsls	r0, r0, #1
 6a0:	47a0      	blx	r4
		delay_ms(500);
 6a2:	20fa      	movs	r0, #250	; 0xfa
 6a4:	0040      	lsls	r0, r0, #1
 6a6:	47a8      	blx	r5
		setBuzzerFreq(700);
 6a8:	20af      	movs	r0, #175	; 0xaf
 6aa:	0080      	lsls	r0, r0, #2
 6ac:	47a0      	blx	r4
		delay_ms(500);
 6ae:	20fa      	movs	r0, #250	; 0xfa
 6b0:	0040      	lsls	r0, r0, #1
 6b2:	47a8      	blx	r5
 6b4:	e7f2      	b.n	69c <main+0x1c>
 6b6:	46c0      	nop			; (mov r8, r8)
 6b8:	000001fd 	.word	0x000001fd
 6bc:	000009c5 	.word	0x000009c5
 6c0:	20000094 	.word	0x20000094
 6c4:	0000074d 	.word	0x0000074d
 6c8:	00000779 	.word	0x00000779
 6cc:	00000975 	.word	0x00000975

000006d0 <HardFault_Handler>:
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 6d0:	f3bf 8f4f 	dsb	sy
 */
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = ((0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 6d4:	4a03      	ldr	r2, [pc, #12]	; (6e4 <HardFault_Handler+0x14>)
 6d6:	4b04      	ldr	r3, [pc, #16]	; (6e8 <HardFault_Handler+0x18>)
 6d8:	60da      	str	r2, [r3, #12]
 6da:	f3bf 8f4f 	dsb	sy
                 SCB_AIRCR_SYSRESETREQ_Msk);
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
 6de:	46c0      	nop			; (mov r8, r8)
 6e0:	e7fd      	b.n	6de <HardFault_Handler+0xe>
 6e2:	46c0      	nop			; (mov r8, r8)
 6e4:	05fa0004 	.word	0x05fa0004
 6e8:	e000ed00 	.word	0xe000ed00

000006ec <adcInit>:
#include <util.h>

void adcInit() {

    // set up clock
    PM->APBCMASK.reg |= PM_APBCMASK_ADC;
 6ec:	2380      	movs	r3, #128	; 0x80

    // divide prescaler by 512 (93.75KHz), max adc freq is 2.1MHz
    ADC->CTRLB.reg = ADC_CTRLB_PRESCALER_DIV512 |
 6ee:	20e0      	movs	r0, #224	; 0xe0
    PM->APBCMASK.reg |= PM_APBCMASK_ADC;
 6f0:	4a10      	ldr	r2, [pc, #64]	; (734 <adcInit+0x48>)
 6f2:	025b      	lsls	r3, r3, #9
 6f4:	6a11      	ldr	r1, [r2, #32]
    ADC->CTRLB.reg = ADC_CTRLB_PRESCALER_DIV512 |
 6f6:	00c0      	lsls	r0, r0, #3
    PM->APBCMASK.reg |= PM_APBCMASK_ADC;
 6f8:	430b      	orrs	r3, r1
 6fa:	6213      	str	r3, [r2, #32]
                     ADC_CTRLB_RESSEL_12BIT;

    // enable clock adc channel
    GCLK->CLKCTRL.reg = GCLK_CLKCTRL_CLKEN |
 6fc:	490e      	ldr	r1, [pc, #56]	; (738 <adcInit+0x4c>)
    ADC->CTRLB.reg = ADC_CTRLB_PRESCALER_DIV512 |
 6fe:	4a0f      	ldr	r2, [pc, #60]	; (73c <adcInit+0x50>)
    GCLK->CLKCTRL.reg = GCLK_CLKCTRL_CLKEN |
 700:	4b0f      	ldr	r3, [pc, #60]	; (740 <adcInit+0x54>)
    ADC->CTRLB.reg = ADC_CTRLB_PRESCALER_DIV512 |
 702:	8090      	strh	r0, [r2, #4]
    GCLK->CLKCTRL.reg = GCLK_CLKCTRL_CLKEN |
 704:	8059      	strh	r1, [r3, #2]
                        GCLK_CLKCTRL_GEN(0) |
                        GCLK_CLKCTRL_ID(ADC_GCLK_ID);

    ADC->CALIB.reg =
        ADC_CALIB_BIAS_CAL(
 706:	4b0f      	ldr	r3, [pc, #60]	; (744 <adcInit+0x58>)
 708:	6819      	ldr	r1, [r3, #0]
 70a:	014b      	lsls	r3, r1, #5
 70c:	4003      	ands	r3, r0
            (*(uint32_t *)ADC_FUSES_BIASCAL_ADDR >> ADC_FUSES_BIASCAL_Pos)
        ) |
        ADC_CALIB_LINEARITY_CAL(
 70e:	0148      	lsls	r0, r1, #5
 710:	490d      	ldr	r1, [pc, #52]	; (748 <adcInit+0x5c>)
 712:	6809      	ldr	r1, [r1, #0]
 714:	0ec9      	lsrs	r1, r1, #27
 716:	4301      	orrs	r1, r0
 718:	20ff      	movs	r0, #255	; 0xff
 71a:	4001      	ands	r1, r0
        ) |
 71c:	430b      	orrs	r3, r1
    ADC->CALIB.reg =
 71e:	8513      	strh	r3, [r2, #40]	; 0x28
            (*(uint64_t *)ADC_FUSES_LINEARITY_0_ADDR >> ADC_FUSES_LINEARITY_0_Pos)
        );

    ADC->REFCTRL.reg = ADC_REFCTRL_REFSEL_INTVCC0;
 720:	2301      	movs	r3, #1
 722:	7053      	strb	r3, [r2, #1]

    ADC->CTRLA.reg = ADC_CTRLA_ENABLE; // enable
 724:	3301      	adds	r3, #1
 726:	7013      	strb	r3, [r2, #0]
    while(ADC->STATUS.reg & ADC_STATUS_SYNCBUSY);
 728:	7e53      	ldrb	r3, [r2, #25]
 72a:	b25b      	sxtb	r3, r3
 72c:	2b00      	cmp	r3, #0
 72e:	dbfb      	blt.n	728 <adcInit+0x3c>
}
 730:	4770      	bx	lr
 732:	46c0      	nop			; (mov r8, r8)
 734:	40000400 	.word	0x40000400
 738:	0000401e 	.word	0x0000401e
 73c:	42004000 	.word	0x42004000
 740:	40000c00 	.word	0x40000c00
 744:	00806024 	.word	0x00806024
 748:	00806020 	.word	0x00806020

0000074c <setBuzzerFreq>:
void stopBuzzing(){
	buzzing = false;
}

void beepDigit(u8_t digit) {
    if (digit == 0) {
 74c:	b510      	push	{r4, lr}
 74e:	0001      	movs	r1, r0
}


inline static void pinToggle(Pin p) {
    PORT->Group[p.group].OUTTGL.reg = (1<<p.pin);
 750:	4b03      	ldr	r3, [pc, #12]	; (760 <setBuzzerFreq+0x14>)
 752:	4804      	ldr	r0, [pc, #16]	; (764 <setBuzzerFreq+0x18>)
 754:	4798      	blx	r3
 756:	4b04      	ldr	r3, [pc, #16]	; (768 <setBuzzerFreq+0x1c>)
 758:	b2c0      	uxtb	r0, r0
 75a:	7518      	strb	r0, [r3, #20]
 75c:	bd10      	pop	{r4, pc}
 75e:	46c0      	nop			; (mov r8, r8)
 760:	00000bf5 	.word	0x00000bf5
        delay_us(120);
 764:	00007a12 	.word	0x00007a12
 768:	42003000 	.word	0x42003000

0000076c <isBuzzing>:
    while(count < beepStop) {
 76c:	4b01      	ldr	r3, [pc, #4]	; (774 <isBuzzing+0x8>)
 76e:	7818      	ldrb	r0, [r3, #0]
        delay_ms(1000);
        beepDigit(number);
        return;
    }
    if (number >=10) {
        beepDigit(number/10);
 770:	b2c0      	uxtb	r0, r0
 772:	4770      	bx	lr
 774:	2000002c 	.word	0x2000002c

00000778 <startBuzzing>:
 778:	2201      	movs	r2, #1
 77a:	4b01      	ldr	r3, [pc, #4]	; (780 <startBuzzing+0x8>)
 77c:	701a      	strb	r2, [r3, #0]
 77e:	4770      	bx	lr
 780:	2000002c 	.word	0x2000002c

00000784 <GclkInit>:
}

void GclkInit(u8_t clk_system) {


    SYSCTRL->INTFLAG.reg = SYSCTRL_INTFLAG_BOD33RDY | SYSCTRL_INTFLAG_BOD33DET |
 784:	22c2      	movs	r2, #194	; 0xc2
                           SYSCTRL_INTFLAG_DFLLRDY;
    NVMCTRL->CTRLB.bit.RWS = 2;
 786:	211e      	movs	r1, #30
    SYSCTRL->INTFLAG.reg = SYSCTRL_INTFLAG_BOD33RDY | SYSCTRL_INTFLAG_BOD33DET |
 788:	4b22      	ldr	r3, [pc, #136]	; (814 <GclkInit+0x90>)
 78a:	00d2      	lsls	r2, r2, #3
 78c:	609a      	str	r2, [r3, #8]
    NVMCTRL->CTRLB.bit.RWS = 2;
 78e:	4a22      	ldr	r2, [pc, #136]	; (818 <GclkInit+0x94>)
 790:	6853      	ldr	r3, [r2, #4]
 792:	438b      	bics	r3, r1
 794:	391a      	subs	r1, #26
 796:	430b      	orrs	r3, r1
 798:	6053      	str	r3, [r2, #4]

    // Initialize GCLK
    PM->APBAMASK.reg |= PM_APBAMASK_GCLK;
 79a:	4a20      	ldr	r2, [pc, #128]	; (81c <GclkInit+0x98>)
 79c:	3104      	adds	r1, #4
 79e:	6993      	ldr	r3, [r2, #24]
 7a0:	430b      	orrs	r3, r1
 7a2:	6193      	str	r3, [r2, #24]
    GCLK->CTRL.reg = GCLK_CTRL_SWRST;
 7a4:	2301      	movs	r3, #1
 7a6:	4a1e      	ldr	r2, [pc, #120]	; (820 <GclkInit+0x9c>)
    while (GCLK->CTRL.reg & GCLK_CTRL_SWRST);
 7a8:	3907      	subs	r1, #7
    GCLK->CTRL.reg = GCLK_CTRL_SWRST;
 7aa:	7013      	strb	r3, [r2, #0]
    while (GCLK->CTRL.reg & GCLK_CTRL_SWRST);
 7ac:	7813      	ldrb	r3, [r2, #0]
 7ae:	4219      	tst	r1, r3
 7b0:	d1fc      	bne.n	7ac <GclkInit+0x28>

    // Disable ONDEMAND mode while writing configurations (errata 9905)
    SYSCTRL->DFLLCTRL.reg = dfll_ctrl & ~SYSCTRL_DFLLCTRL_ONDEMAND;
 7b2:	4a18      	ldr	r2, [pc, #96]	; (814 <GclkInit+0x90>)
 7b4:	4b1b      	ldr	r3, [pc, #108]	; (824 <GclkInit+0xa0>)
 7b6:	8493      	strh	r3, [r2, #36]	; 0x24
    while (!SYSCTRL->PCLKSR.bit.DFLLRDY);
 7b8:	68d3      	ldr	r3, [r2, #12]
 7ba:	06db      	lsls	r3, r3, #27
 7bc:	d5fc      	bpl.n	7b8 <GclkInit+0x34>
    uint32_t coarse = ( *((uint32_t *)(NVMCTRL_OTP4)
 7be:	4b1a      	ldr	r3, [pc, #104]	; (828 <GclkInit+0xa4>)
 7c0:	681b      	ldr	r3, [r3, #0]
 7c2:	0e9b      	lsrs	r3, r3, #26
    if (coarse == 0x3f) {
 7c4:	2b3f      	cmp	r3, #63	; 0x3f
 7c6:	d019      	beq.n	7fc <GclkInit+0x78>
 7c8:	029a      	lsls	r2, r3, #10
                      >> (NVM_DFLL_FINE_POS % 32))
 7ca:	4b18      	ldr	r3, [pc, #96]	; (82c <GclkInit+0xa8>)
    if (fine == 0x3ff) {
 7cc:	4918      	ldr	r1, [pc, #96]	; (830 <GclkInit+0xac>)
    uint32_t fine = ( *((uint32_t *)(NVMCTRL_OTP4)
 7ce:	681b      	ldr	r3, [r3, #0]
 7d0:	059b      	lsls	r3, r3, #22
 7d2:	0d9b      	lsrs	r3, r3, #22
    if (fine == 0x3ff) {
 7d4:	428b      	cmp	r3, r1
 7d6:	d01a      	beq.n	80e <GclkInit+0x8a>
    return SYSCTRL_DFLLVAL_COARSE(coarse) | SYSCTRL_DFLLVAL_FINE(fine);
 7d8:	4313      	orrs	r3, r2
    dfll_wait_for_sync();
    SYSCTRL->DFLLVAL.reg = dfll_nvm_val();
 7da:	4a0e      	ldr	r2, [pc, #56]	; (814 <GclkInit+0x90>)
 7dc:	6293      	str	r3, [r2, #40]	; 0x28
    while (!SYSCTRL->PCLKSR.bit.DFLLRDY);
 7de:	68d3      	ldr	r3, [r2, #12]
 7e0:	06db      	lsls	r3, r3, #27
 7e2:	d5fc      	bpl.n	7de <GclkInit+0x5a>
    dfll_wait_for_sync();
    SYSCTRL->DFLLCTRL.reg = dfll_ctrl;
 7e4:	4b13      	ldr	r3, [pc, #76]	; (834 <GclkInit+0xb0>)
 7e6:	8493      	strh	r3, [r2, #36]	; 0x24
    GCLK->GENDIV.reg = GCLK_GENDIV_ID(id) | GCLK_GENDIV_DIV(div);
 7e8:	230f      	movs	r3, #15
 7ea:	4a0d      	ldr	r2, [pc, #52]	; (820 <GclkInit+0x9c>)
 7ec:	4018      	ands	r0, r3
 7ee:	33f1      	adds	r3, #241	; 0xf1
 7f0:	4303      	orrs	r3, r0
 7f2:	6093      	str	r3, [r2, #8]
    GCLK->GENCTRL.reg = GCLK_GENCTRL_ID(id) | GCLK_GENCTRL_GENEN | GCLK_GENCTRL_SRC(src);
 7f4:	4b10      	ldr	r3, [pc, #64]	; (838 <GclkInit+0xb4>)
 7f6:	4318      	orrs	r0, r3
 7f8:	6050      	str	r0, [r2, #4]


    //For generic clock generator 0, select the DFLL48 Clock as input
    gclk_enable(clk_system, GCLK_SOURCE_DFLL48M, 1);
}
 7fa:	4770      	bx	lr
    if (coarse == 0x3f) {
 7fc:	22f8      	movs	r2, #248	; 0xf8
                      >> (NVM_DFLL_FINE_POS % 32))
 7fe:	4b0b      	ldr	r3, [pc, #44]	; (82c <GclkInit+0xa8>)
    if (fine == 0x3ff) {
 800:	490b      	ldr	r1, [pc, #44]	; (830 <GclkInit+0xac>)
    uint32_t fine = ( *((uint32_t *)(NVMCTRL_OTP4)
 802:	681b      	ldr	r3, [r3, #0]
    if (coarse == 0x3f) {
 804:	01d2      	lsls	r2, r2, #7
    uint32_t fine = ( *((uint32_t *)(NVMCTRL_OTP4)
 806:	059b      	lsls	r3, r3, #22
 808:	0d9b      	lsrs	r3, r3, #22
    if (fine == 0x3ff) {
 80a:	428b      	cmp	r3, r1
 80c:	d1e4      	bne.n	7d8 <GclkInit+0x54>
        fine = 0x1ff;
 80e:	4b0b      	ldr	r3, [pc, #44]	; (83c <GclkInit+0xb8>)
 810:	e7e2      	b.n	7d8 <GclkInit+0x54>
 812:	46c0      	nop			; (mov r8, r8)
 814:	40000800 	.word	0x40000800
 818:	41004000 	.word	0x41004000
 81c:	40000400 	.word	0x40000400
 820:	40000c00 	.word	0x40000c00
 824:	00000502 	.word	0x00000502
 828:	00806024 	.word	0x00806024
 82c:	00806028 	.word	0x00806028
 830:	000003ff 	.word	0x000003ff
 834:	00000582 	.word	0x00000582
 838:	00010700 	.word	0x00010700
 83c:	000001ff 	.word	0x000001ff

00000840 <buzzerInit>:

void buzzerInit(){
	
	
  
}
 840:	4770      	bx	lr
 842:	46c0      	nop			; (mov r8, r8)

00000844 <RtcInit>:

void RtcInit() {

    SYSCTRL->OSC32K.reg = SYSCTRL_OSC32K_ENABLE |
 844:	4a27      	ldr	r2, [pc, #156]	; (8e4 <RtcInit+0xa0>)
 846:	4b28      	ldr	r3, [pc, #160]	; (8e8 <RtcInit+0xa4>)
void RtcInit() {
 848:	b510      	push	{r4, lr}
    SYSCTRL->OSC32K.reg = SYSCTRL_OSC32K_ENABLE |
 84a:	6193      	str	r3, [r2, #24]
                          SYSCTRL_OSC32K_EN32K |
                          ( 6 << SYSCTRL_OSC32K_STARTUP_Pos);

    SYSCTRL->OSC32K.bit.CALIB =
        ((*(uint32_t *)FUSES_OSC32K_CAL_ADDR >>
 84c:	4b27      	ldr	r3, [pc, #156]	; (8ec <RtcInit+0xa8>)
    SYSCTRL->OSC32K.bit.CALIB =
 84e:	6990      	ldr	r0, [r2, #24]
        ((*(uint32_t *)FUSES_OSC32K_CAL_ADDR >>
 850:	681b      	ldr	r3, [r3, #0]
    SYSCTRL->OSC32K.bit.CALIB =
 852:	4c27      	ldr	r4, [pc, #156]	; (8f0 <RtcInit+0xac>)
          FUSES_OSC32K_CAL_Pos) & 0x7Ful);
 854:	04db      	lsls	r3, r3, #19
    SYSCTRL->OSC32K.bit.CALIB =
 856:	0e5b      	lsrs	r3, r3, #25
 858:	041b      	lsls	r3, r3, #16

    SYSCTRL->OSC32K.reg = SYSCTRL_OSC32K_STARTUP( 0x6u ) | // cf table 15.10 of product datasheet in chapter 15.8.6
 85a:	4926      	ldr	r1, [pc, #152]	; (8f4 <RtcInit+0xb0>)
    SYSCTRL->OSC32K.bit.CALIB =
 85c:	4020      	ands	r0, r4
 85e:	4318      	orrs	r0, r3
 860:	6190      	str	r0, [r2, #24]
    SYSCTRL->OSC32K.reg = SYSCTRL_OSC32K_STARTUP( 0x6u ) | // cf table 15.10 of product datasheet in chapter 15.8.6
 862:	6191      	str	r1, [r2, #24]
                          SYSCTRL_OSC32K_EN32K;
    SYSCTRL->OSC32K.bit.CALIB =
 864:	6991      	ldr	r1, [r2, #24]
 866:	4021      	ands	r1, r4
 868:	430b      	orrs	r3, r1
        ((*(uint32_t *)FUSES_OSC32K_CAL_ADDR >>
          FUSES_OSC32K_CAL_Pos) & 0x7Ful);

    SYSCTRL->OSC32K.bit.ENABLE = 1; // separate call, as described in chapter 15.6.3
 86a:	2102      	movs	r1, #2
    SYSCTRL->OSC32K.bit.CALIB =
 86c:	6193      	str	r3, [r2, #24]
    SYSCTRL->OSC32K.bit.ENABLE = 1; // separate call, as described in chapter 15.6.3
 86e:	6993      	ldr	r3, [r2, #24]
 870:	430b      	orrs	r3, r1
 872:	6193      	str	r3, [r2, #24]

    while (  (SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_OSC32KRDY) == 0 ) {
 874:	3102      	adds	r1, #2
 876:	68d3      	ldr	r3, [r2, #12]
 878:	4219      	tst	r1, r3
 87a:	d0fc      	beq.n	876 <RtcInit+0x32>
        // Wait for oscillator stabilization
    }

    GCLK->GENDIV.reg = GCLK_GENDIV_ID(2) | GCLK_GENDIV_DIV(1);
 87c:	2381      	movs	r3, #129	; 0x81
 87e:	4a1e      	ldr	r2, [pc, #120]	; (8f8 <RtcInit+0xb4>)
 880:	005b      	lsls	r3, r3, #1
 882:	6093      	str	r3, [r2, #8]

    GCLK->GENCTRL.reg = GCLK_GENCTRL_ID(2) |
 884:	4b1d      	ldr	r3, [pc, #116]	; (8fc <RtcInit+0xb8>)
 886:	6053      	str	r3, [r2, #4]
                        GCLK_GENCTRL_SRC(GCLK_GENCTRL_SRC_OSC32K) |
                        GCLK_GENCTRL_IDC |
                        GCLK_GENCTRL_RUNSTDBY |
                        GCLK_GENCTRL_GENEN;
    while (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY);
 888:	7853      	ldrb	r3, [r2, #1]
 88a:	b25b      	sxtb	r3, r3
 88c:	2b00      	cmp	r3, #0
 88e:	dbfb      	blt.n	888 <RtcInit+0x44>

// Configure RTC
    GCLK->CLKCTRL.reg = GCLK_CLKCTRL_ID(RTC_GCLK_ID) |
 890:	4b1b      	ldr	r3, [pc, #108]	; (900 <RtcInit+0xbc>)
 892:	8053      	strh	r3, [r2, #2]
                        GCLK_CLKCTRL_CLKEN |
                        GCLK_CLKCTRL_GEN(2);

    RTC->MODE1.CTRL.reg = RTC_MODE1_CTRL_MODE_COUNT16;
 894:	2304      	movs	r3, #4
 896:	4a1b      	ldr	r2, [pc, #108]	; (904 <RtcInit+0xc0>)
 898:	8013      	strh	r3, [r2, #0]
    while (RTC->MODE1.STATUS.bit.SYNCBUSY);
 89a:	7a93      	ldrb	r3, [r2, #10]
 89c:	09db      	lsrs	r3, r3, #7
 89e:	d1fc      	bne.n	89a <RtcInit+0x56>

// Prescaler needs to be enabled separately from the mode for some reason
    RTC->MODE1.CTRL.reg |= RTC_MODE1_CTRL_PRESCALER_DIV32;
 8a0:	23a0      	movs	r3, #160	; 0xa0
 8a2:	8811      	ldrh	r1, [r2, #0]
 8a4:	00db      	lsls	r3, r3, #3
 8a6:	430b      	orrs	r3, r1
 8a8:	8013      	strh	r3, [r2, #0]
    while (RTC->MODE1.STATUS.bit.SYNCBUSY);
 8aa:	4a16      	ldr	r2, [pc, #88]	; (904 <RtcInit+0xc0>)
 8ac:	7a93      	ldrb	r3, [r2, #10]
 8ae:	09db      	lsrs	r3, r3, #7
 8b0:	d1fc      	bne.n	8ac <RtcInit+0x68>

    RTC->MODE1.PER.reg = 998;
 8b2:	4b15      	ldr	r3, [pc, #84]	; (908 <RtcInit+0xc4>)
 8b4:	8293      	strh	r3, [r2, #20]
    while (RTC->MODE1.STATUS.bit.SYNCBUSY);
 8b6:	4a13      	ldr	r2, [pc, #76]	; (904 <RtcInit+0xc0>)
 8b8:	7a93      	ldrb	r3, [r2, #10]
 8ba:	09db      	lsrs	r3, r3, #7
 8bc:	d1fc      	bne.n	8b8 <RtcInit+0x74>

    RTC->MODE1.READREQ.reg |= RTC_READREQ_RCONT | RTC_READREQ_ADDR(0x10);
 8be:	8851      	ldrh	r1, [r2, #2]
 8c0:	4b12      	ldr	r3, [pc, #72]	; (90c <RtcInit+0xc8>)
 8c2:	430b      	orrs	r3, r1
 8c4:	8053      	strh	r3, [r2, #2]

    RTC->MODE1.INTENSET.reg = RTC_MODE1_INTENSET_OVF;
 8c6:	2380      	movs	r3, #128	; 0x80

    RTC->MODE1.CTRL.bit.ENABLE = 1;
 8c8:	2102      	movs	r1, #2
    RTC->MODE1.INTENSET.reg = RTC_MODE1_INTENSET_OVF;
 8ca:	71d3      	strb	r3, [r2, #7]
    RTC->MODE1.CTRL.bit.ENABLE = 1;
 8cc:	8813      	ldrh	r3, [r2, #0]
 8ce:	430b      	orrs	r3, r1
 8d0:	8013      	strh	r3, [r2, #0]
    while (RTC->MODE1.STATUS.bit.SYNCBUSY);
 8d2:	4a0c      	ldr	r2, [pc, #48]	; (904 <RtcInit+0xc0>)
 8d4:	7a93      	ldrb	r3, [r2, #10]
 8d6:	09db      	lsrs	r3, r3, #7
 8d8:	d1fc      	bne.n	8d4 <RtcInit+0x90>
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8da:	2208      	movs	r2, #8
 8dc:	4b0c      	ldr	r3, [pc, #48]	; (910 <RtcInit+0xcc>)
 8de:	601a      	str	r2, [r3, #0]

    NVIC_EnableIRQ(RTC_IRQn);
}
 8e0:	bd10      	pop	{r4, pc}
 8e2:	46c0      	nop			; (mov r8, r8)
 8e4:	40000800 	.word	0x40000800
 8e8:	00000606 	.word	0x00000606
 8ec:	00806024 	.word	0x00806024
 8f0:	ff80ffff 	.word	0xff80ffff
 8f4:	00000604 	.word	0x00000604
 8f8:	40000c00 	.word	0x40000c00
 8fc:	00230002 	.word	0x00230002
 900:	00004204 	.word	0x00004204
 904:	40001400 	.word	0x40001400
 908:	000003e6 	.word	0x000003e6
 90c:	00004010 	.word	0x00004010
 910:	e000e100 	.word	0xe000e100

00000914 <gclkEnable>:


void gclkEnable(u32_t id, u32_t src, u32_t div) {
    GCLK->GENDIV.reg = GCLK_GENDIV_ID(id) | GCLK_GENDIV_DIV(div);
 914:	230f      	movs	r3, #15
 916:	4003      	ands	r3, r0
 918:	4808      	ldr	r0, [pc, #32]	; (93c <gclkEnable+0x28>)
 91a:	0212      	lsls	r2, r2, #8
 91c:	4002      	ands	r2, r0
    GCLK->GENCTRL.reg = GCLK_GENCTRL_ID(id) | GCLK_GENCTRL_GENEN | GCLK_GENCTRL_SRC(src);
 91e:	20f8      	movs	r0, #248	; 0xf8
 920:	0209      	lsls	r1, r1, #8
 922:	0140      	lsls	r0, r0, #5
 924:	4001      	ands	r1, r0
 926:	2080      	movs	r0, #128	; 0x80
void gclkEnable(u32_t id, u32_t src, u32_t div) {
 928:	b510      	push	{r4, lr}
    GCLK->GENCTRL.reg = GCLK_GENCTRL_ID(id) | GCLK_GENCTRL_GENEN | GCLK_GENCTRL_SRC(src);
 92a:	0240      	lsls	r0, r0, #9
    GCLK->GENDIV.reg = GCLK_GENDIV_ID(id) | GCLK_GENDIV_DIV(div);
 92c:	4c04      	ldr	r4, [pc, #16]	; (940 <gclkEnable+0x2c>)
    GCLK->GENCTRL.reg = GCLK_GENCTRL_ID(id) | GCLK_GENCTRL_GENEN | GCLK_GENCTRL_SRC(src);
 92e:	4308      	orrs	r0, r1
    GCLK->GENDIV.reg = GCLK_GENDIV_ID(id) | GCLK_GENDIV_DIV(div);
 930:	431a      	orrs	r2, r3
    GCLK->GENCTRL.reg = GCLK_GENCTRL_ID(id) | GCLK_GENCTRL_GENEN | GCLK_GENCTRL_SRC(src);
 932:	4318      	orrs	r0, r3
    GCLK->GENDIV.reg = GCLK_GENDIV_ID(id) | GCLK_GENDIV_DIV(div);
 934:	60a2      	str	r2, [r4, #8]
    GCLK->GENCTRL.reg = GCLK_GENCTRL_ID(id) | GCLK_GENCTRL_GENEN | GCLK_GENCTRL_SRC(src);
 936:	6060      	str	r0, [r4, #4]
}
 938:	bd10      	pop	{r4, pc}
 93a:	46c0      	nop			; (mov r8, r8)
 93c:	00ffff00 	.word	0x00ffff00
 940:	40000c00 	.word	0x40000c00

00000944 <delayInit>:


void delayInit(void) {
    cycles_per_ms = 48000000UL;
    cycles_per_ms /= 1000;
    cycles_per_us = cycles_per_ms / 1000;
 944:	2230      	movs	r2, #48	; 0x30
    cycles_per_ms /= 1000;
 946:	4b06      	ldr	r3, [pc, #24]	; (960 <delayInit+0x1c>)
    cycles_per_us = cycles_per_ms / 1000;
 948:	4906      	ldr	r1, [pc, #24]	; (964 <delayInit+0x20>)
 94a:	c306      	stmia	r3!, {r1, r2}
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 94c:	4a06      	ldr	r2, [pc, #24]	; (968 <delayInit+0x24>)
 94e:	6a13      	ldr	r3, [r2, #32]
 950:	021b      	lsls	r3, r3, #8
 952:	0a1b      	lsrs	r3, r3, #8
 954:	6213      	str	r3, [r2, #32]

    NVIC_SetPriority(SysTick_IRQn, 0x0);

    SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk;
 956:	2205      	movs	r2, #5
 958:	4b04      	ldr	r3, [pc, #16]	; (96c <delayInit+0x28>)
 95a:	601a      	str	r2, [r3, #0]
}
 95c:	4770      	bx	lr
 95e:	46c0      	nop			; (mov r8, r8)
 960:	20000004 	.word	0x20000004
 964:	0000bb80 	.word	0x0000bb80
 968:	e000ed00 	.word	0xe000ed00
 96c:	e000e010 	.word	0xe000e010

00000970 <SysTick_Handler>:
}


void SysTick_Handler(void) {
    //g_msTicks++;
}
 970:	4770      	bx	lr
 972:	46c0      	nop			; (mov r8, r8)

00000974 <delay_ms>:
    const uint32_t n) {
    if (n > 0) {
        SysTick->LOAD = n;
        SysTick->VAL = 0;

        while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk)) {
 974:	2180      	movs	r1, #128	; 0x80
/**
 * \brief Delay loop to delay at least n number of milliseconds
 *
 * \param n  Number of milliseconds to wait
 */
void delay_ms(uint32_t n) {
 976:	b530      	push	{r4, r5, lr}
        SysTick->VAL = 0;
 978:	2500      	movs	r5, #0
    while (n--) {
        /* Devide up to blocks of 1ms */
        delay_cycles(cycles_per_ms);
 97a:	4b08      	ldr	r3, [pc, #32]	; (99c <delay_ms+0x28>)
        SysTick->LOAD = n;
 97c:	4a08      	ldr	r2, [pc, #32]	; (9a0 <delay_ms+0x2c>)
 97e:	681c      	ldr	r4, [r3, #0]
        while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk)) {
 980:	0249      	lsls	r1, r1, #9
    while (n--) {
 982:	3801      	subs	r0, #1
 984:	d308      	bcc.n	998 <delay_ms+0x24>
    if (n > 0) {
 986:	2c00      	cmp	r4, #0
 988:	d0fb      	beq.n	982 <delay_ms+0xe>
        SysTick->LOAD = n;
 98a:	6054      	str	r4, [r2, #4]
        SysTick->VAL = 0;
 98c:	6095      	str	r5, [r2, #8]
        while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk)) {
 98e:	6813      	ldr	r3, [r2, #0]
 990:	420b      	tst	r3, r1
 992:	d0fc      	beq.n	98e <delay_ms+0x1a>
 994:	3801      	subs	r0, #1
 996:	d2f6      	bcs.n	986 <delay_ms+0x12>
    }
}
 998:	bd30      	pop	{r4, r5, pc}
 99a:	46c0      	nop			; (mov r8, r8)
 99c:	20000004 	.word	0x20000004
 9a0:	e000e010 	.word	0xe000e010

000009a4 <RTC_Handler>:


volatile uint32_t time_ms = 0;

void RTC_Handler(void) {
    time_ms += 1000;
 9a4:	21fa      	movs	r1, #250	; 0xfa
 9a6:	0089      	lsls	r1, r1, #2
 9a8:	468c      	mov	ip, r1
 9aa:	4a04      	ldr	r2, [pc, #16]	; (9bc <RTC_Handler+0x18>)
 9ac:	6813      	ldr	r3, [r2, #0]
 9ae:	4463      	add	r3, ip
 9b0:	6013      	str	r3, [r2, #0]
    RTC->MODE1.INTFLAG.reg = 0xFF;
 9b2:	22ff      	movs	r2, #255	; 0xff
 9b4:	4b02      	ldr	r3, [pc, #8]	; (9c0 <RTC_Handler+0x1c>)
 9b6:	721a      	strb	r2, [r3, #8]
}
 9b8:	4770      	bx	lr
 9ba:	46c0      	nop			; (mov r8, r8)
 9bc:	20000030 	.word	0x20000030
 9c0:	40001400 	.word	0x40001400

000009c4 <millis>:

uint32_t millis(void) {
 9c4:	b530      	push	{r4, r5, lr}
    uint32_t ms;
    ATOMIC_SECTION_ENTER
 9c6:	f3ef 8410 	mrs	r4, PRIMASK
 9ca:	b672      	cpsid	i
    ms = time_ms + RTC->MODE1.COUNT.reg;
 9cc:	4a09      	ldr	r2, [pc, #36]	; (9f4 <millis+0x30>)
 9ce:	490a      	ldr	r1, [pc, #40]	; (9f8 <millis+0x34>)
 9d0:	8a10      	ldrh	r0, [r2, #16]
 9d2:	680d      	ldr	r5, [r1, #0]
    if (RTC->MODE1.INTFLAG.bit.OVF)
 9d4:	7a13      	ldrb	r3, [r2, #8]
    ms = time_ms + RTC->MODE1.COUNT.reg;
 9d6:	b280      	uxth	r0, r0
    if (RTC->MODE1.INTFLAG.bit.OVF)
 9d8:	09db      	lsrs	r3, r3, #7
    ms = time_ms + RTC->MODE1.COUNT.reg;
 9da:	1940      	adds	r0, r0, r5
    if (RTC->MODE1.INTFLAG.bit.OVF)
 9dc:	2b00      	cmp	r3, #0
 9de:	d006      	beq.n	9ee <millis+0x2a>
        ms = time_ms + RTC->MODE1.COUNT.reg + 1000;
 9e0:	8a13      	ldrh	r3, [r2, #16]
 9e2:	22fa      	movs	r2, #250	; 0xfa
 9e4:	0092      	lsls	r2, r2, #2
 9e6:	4694      	mov	ip, r2
 9e8:	6808      	ldr	r0, [r1, #0]
 9ea:	4460      	add	r0, ip
 9ec:	18c0      	adds	r0, r0, r3
    ATOMIC_SECTION_LEAVE
 9ee:	f384 8810 	msr	PRIMASK, r4
    return ms;
}
 9f2:	bd30      	pop	{r4, r5, pc}
 9f4:	40001400 	.word	0x40001400
 9f8:	20000030 	.word	0x20000030

000009fc <TC4Init>:
void TC4Init() {
	
	SYSCTRL->OSC8M.reg = SYSCTRL_OSC8M_ENABLE |
						 SYSCTRL_OSC8M_FRANGE_1;
	
	while (  (SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_OSC8MRDY) == 0 ) {
 9fc:	2108      	movs	r1, #8
	SYSCTRL->OSC8M.reg = SYSCTRL_OSC8M_ENABLE |
 9fe:	4a15      	ldr	r2, [pc, #84]	; (a54 <TC4Init+0x58>)
 a00:	4b15      	ldr	r3, [pc, #84]	; (a58 <TC4Init+0x5c>)
 a02:	6213      	str	r3, [r2, #32]
	while (  (SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_OSC8MRDY) == 0 ) {
 a04:	68d3      	ldr	r3, [r2, #12]
 a06:	4219      	tst	r1, r3
 a08:	d0fc      	beq.n	a04 <TC4Init+0x8>
		// Wait for oscillator stabilization
	}
	
	
	GCLK->GENDIV.reg = GCLK_GENDIV_ID(3) | GCLK_GENDIV_DIV(1);
 a0a:	2304      	movs	r3, #4
 a0c:	4a13      	ldr	r2, [pc, #76]	; (a5c <TC4Init+0x60>)
 a0e:	33ff      	adds	r3, #255	; 0xff
 a10:	6093      	str	r3, [r2, #8]

	GCLK->GENCTRL.reg = GCLK_GENCTRL_ID(3) |
 a12:	4b13      	ldr	r3, [pc, #76]	; (a60 <TC4Init+0x64>)
 a14:	6053      	str	r3, [r2, #4]
						GCLK_GENCTRL_SRC(GCLK_GENCTRL_SRC_OSC8M) |
						GCLK_GENCTRL_IDC |
						GCLK_GENCTRL_RUNSTDBY |
						GCLK_GENCTRL_GENEN;
	while (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY);
 a16:	7853      	ldrb	r3, [r2, #1]
 a18:	b25b      	sxtb	r3, r3
 a1a:	2b00      	cmp	r3, #0
 a1c:	dbfb      	blt.n	a16 <TC4Init+0x1a>
	
	
	

    GCLK->CLKCTRL.reg = GCLK_CLKCTRL_ID_TC4_TC5 |
 a1e:	4b11      	ldr	r3, [pc, #68]	; (a64 <TC4Init+0x68>)
 a20:	8053      	strh	r3, [r2, #2]
                        GCLK_CLKCTRL_CLKEN |
                        GCLK_CLKCTRL_GEN(3);
						
	

    PM->APBCMASK.reg |= PM_APBCMASK_TC4;
 a22:	2380      	movs	r3, #128	; 0x80
 a24:	4a10      	ldr	r2, [pc, #64]	; (a68 <TC4Init+0x6c>)
 a26:	015b      	lsls	r3, r3, #5
 a28:	6a11      	ldr	r1, [r2, #32]
 a2a:	430b      	orrs	r3, r1
 a2c:	6213      	str	r3, [r2, #32]

    TC4->COUNT8.CTRLA.reg = TC_CTRLA_MODE_COUNT8 |
 a2e:	4b0f      	ldr	r3, [pc, #60]	; (a6c <TC4Init+0x70>)
 a30:	4a0f      	ldr	r2, [pc, #60]	; (a70 <TC4Init+0x74>)

    TC4->COUNT8.INTENSET.reg = TC_INTENSET_OVF;

    TC4->COUNT8.EVCTRL.reg = TC_EVCTRL_OVFEO;

    TC4->COUNT8.CTRLA.reg |= TC_CTRLA_ENABLE;
 a32:	2102      	movs	r1, #2
    TC4->COUNT8.CTRLA.reg = TC_CTRLA_MODE_COUNT8 |
 a34:	801a      	strh	r2, [r3, #0]
    TC4->COUNT8.PER.reg = 0x50;
 a36:	2250      	movs	r2, #80	; 0x50
 a38:	751a      	strb	r2, [r3, #20]
    TC4->COUNT8.INTENSET.reg = TC_INTENSET_OVF;
 a3a:	3a4f      	subs	r2, #79	; 0x4f
 a3c:	735a      	strb	r2, [r3, #13]
    TC4->COUNT8.EVCTRL.reg = TC_EVCTRL_OVFEO;
 a3e:	32ff      	adds	r2, #255	; 0xff
 a40:	815a      	strh	r2, [r3, #10]
    TC4->COUNT8.CTRLA.reg |= TC_CTRLA_ENABLE;
 a42:	881a      	ldrh	r2, [r3, #0]
 a44:	430a      	orrs	r2, r1
 a46:	801a      	strh	r2, [r3, #0]
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 a48:	2280      	movs	r2, #128	; 0x80
 a4a:	4b0a      	ldr	r3, [pc, #40]	; (a74 <TC4Init+0x78>)
 a4c:	0312      	lsls	r2, r2, #12
 a4e:	601a      	str	r2, [r3, #0]

    NVIC_EnableIRQ(TC4_IRQn);
}
 a50:	4770      	bx	lr
 a52:	46c0      	nop			; (mov r8, r8)
 a54:	40000800 	.word	0x40000800
 a58:	40000002 	.word	0x40000002
 a5c:	40000c00 	.word	0x40000c00
 a60:	00230003 	.word	0x00230003
 a64:	0000431c 	.word	0x0000431c
 a68:	40000400 	.word	0x40000400
 a6c:	42003000 	.word	0x42003000
 a70:	00000e04 	.word	0x00000e04
 a74:	e000e100 	.word	0xe000e100

00000a78 <TC4_Handler>:

void TC4_Handler( void ) {
 a78:	b510      	push	{r4, lr}
	if (isBuzzing())
 a7a:	4b06      	ldr	r3, [pc, #24]	; (a94 <TC4_Handler+0x1c>)
 a7c:	4798      	blx	r3
 a7e:	2800      	cmp	r0, #0
 a80:	d003      	beq.n	a8a <TC4_Handler+0x12>
 a82:	2280      	movs	r2, #128	; 0x80
 a84:	4b04      	ldr	r3, [pc, #16]	; (a98 <TC4_Handler+0x20>)
 a86:	0392      	lsls	r2, r2, #14
 a88:	61da      	str	r2, [r3, #28]
	{
    pinToggle(buzzerPin);
	}
	TC4->COUNT8.INTFLAG.reg = 0xFF;
 a8a:	22ff      	movs	r2, #255	; 0xff
 a8c:	4b03      	ldr	r3, [pc, #12]	; (a9c <TC4_Handler+0x24>)
 a8e:	739a      	strb	r2, [r3, #14]

}
 a90:	bd10      	pop	{r4, pc}
 a92:	46c0      	nop			; (mov r8, r8)
 a94:	0000076d 	.word	0x0000076d
 a98:	41004400 	.word	0x41004400
 a9c:	42003000 	.word	0x42003000

00000aa0 <TC5Init>:

void TC5Init() {

    GCLK->CLKCTRL.reg = GCLK_CLKCTRL_ID(TC5_GCLK_ID) |
 aa0:	4a0d      	ldr	r2, [pc, #52]	; (ad8 <TC5Init+0x38>)
 aa2:	4b0e      	ldr	r3, [pc, #56]	; (adc <TC5Init+0x3c>)
 aa4:	805a      	strh	r2, [r3, #2]
                        GCLK_CLKCTRL_CLKEN |
                        GCLK_CLKCTRL_GEN(3);

    PM->APBCMASK.reg |= PM_APBCMASK_TC5;
 aa6:	2380      	movs	r3, #128	; 0x80
 aa8:	4a0d      	ldr	r2, [pc, #52]	; (ae0 <TC5Init+0x40>)
 aaa:	019b      	lsls	r3, r3, #6
 aac:	6a11      	ldr	r1, [r2, #32]
 aae:	430b      	orrs	r3, r1
 ab0:	6213      	str	r3, [r2, #32]

    TC5->COUNT8.CTRLA.reg = TC_CTRLA_MODE_COUNT8 |
 ab2:	4b0c      	ldr	r3, [pc, #48]	; (ae4 <TC5Init+0x44>)
 ab4:	4a0c      	ldr	r2, [pc, #48]	; (ae8 <TC5Init+0x48>)

    TC5->COUNT8.INTENSET.reg = TC_INTENSET_OVF;

    TC5->COUNT8.EVCTRL.reg = TC_EVCTRL_OVFEO;

    TC5->COUNT8.CTRLA.reg |= TC_CTRLA_ENABLE;
 ab6:	2102      	movs	r1, #2
    TC5->COUNT8.CTRLA.reg = TC_CTRLA_MODE_COUNT8 |
 ab8:	801a      	strh	r2, [r3, #0]
    TC5->COUNT8.PER.reg = PER_Reg;
 aba:	2266      	movs	r2, #102	; 0x66
 abc:	751a      	strb	r2, [r3, #20]
    TC5->COUNT8.INTENSET.reg = TC_INTENSET_OVF;
 abe:	3a65      	subs	r2, #101	; 0x65
 ac0:	735a      	strb	r2, [r3, #13]
    TC5->COUNT8.EVCTRL.reg = TC_EVCTRL_OVFEO;
 ac2:	32ff      	adds	r2, #255	; 0xff
 ac4:	815a      	strh	r2, [r3, #10]
    TC5->COUNT8.CTRLA.reg |= TC_CTRLA_ENABLE;
 ac6:	881a      	ldrh	r2, [r3, #0]
 ac8:	430a      	orrs	r2, r1
 aca:	801a      	strh	r2, [r3, #0]
 acc:	2280      	movs	r2, #128	; 0x80
 ace:	4b07      	ldr	r3, [pc, #28]	; (aec <TC5Init+0x4c>)
 ad0:	0352      	lsls	r2, r2, #13
 ad2:	601a      	str	r2, [r3, #0]

    NVIC_EnableIRQ(TC5_IRQn);
}
 ad4:	4770      	bx	lr
 ad6:	46c0      	nop			; (mov r8, r8)
 ad8:	0000431c 	.word	0x0000431c
 adc:	40000c00 	.word	0x40000c00
 ae0:	40000400 	.word	0x40000400
 ae4:	42003400 	.word	0x42003400
 ae8:	00000c04 	.word	0x00000c04
 aec:	e000e100 	.word	0xe000e100

00000af0 <TC5_Handler>:

void TC5_Handler( void ) {
    TC5->COUNT8.INTFLAG.reg = 0xFF;
 af0:	22ff      	movs	r2, #255	; 0xff
 af2:	4b03      	ldr	r3, [pc, #12]	; (b00 <TC5_Handler+0x10>)
 af4:	739a      	strb	r2, [r3, #14]
    writeLog = true;
 af6:	4b03      	ldr	r3, [pc, #12]	; (b04 <TC5_Handler+0x14>)
 af8:	3afe      	subs	r2, #254	; 0xfe
 afa:	701a      	strb	r2, [r3, #0]
}
 afc:	4770      	bx	lr
 afe:	46c0      	nop			; (mov r8, r8)
 b00:	42003400 	.word	0x42003400
 b04:	20000092 	.word	0x20000092

00000b08 <sercomClockEnable>:
#include <util.h>

void sercomClockEnable(SercomId id, uint32_t clock_channel, u8_t divider) {
 b08:	b570      	push	{r4, r5, r6, lr}
 b0a:	0005      	movs	r5, r0
    // prevent this clock write from changing any other clocks
    PM->APBCMASK.reg |= 1 << (PM_APBCMASK_SERCOM0_Pos + id);
 b0c:	2301      	movs	r3, #1
 b0e:	1cae      	adds	r6, r5, #2
 b10:	40b3      	lsls	r3, r6
void sercomClockEnable(SercomId id, uint32_t clock_channel, u8_t divider) {
 b12:	000c      	movs	r4, r1
    PM->APBCMASK.reg |= 1 << (PM_APBCMASK_SERCOM0_Pos + id);
 b14:	490b      	ldr	r1, [pc, #44]	; (b44 <sercomClockEnable+0x3c>)
 b16:	6a08      	ldr	r0, [r1, #32]
 b18:	4303      	orrs	r3, r0
 b1a:	620b      	str	r3, [r1, #32]


    if (clock_channel != 0) {
 b1c:	2c00      	cmp	r4, #0
 b1e:	d003      	beq.n	b28 <sercomClockEnable+0x20>
        // clock generators 3-8 have 8 division factor bits - DIV[7:0]
        gclkEnable(clock_channel, GCLK_SOURCE_DFLL48M, divider);
 b20:	2107      	movs	r1, #7
 b22:	0020      	movs	r0, r4
 b24:	4b08      	ldr	r3, [pc, #32]	; (b48 <sercomClockEnable+0x40>)
 b26:	4798      	blx	r3
    }


    // attach clock
    GCLK->CLKCTRL.reg = GCLK_CLKCTRL_CLKEN |
                        GCLK_CLKCTRL_GEN(clock_channel) |
 b28:	23f0      	movs	r3, #240	; 0xf0
 b2a:	0224      	lsls	r4, r4, #8
 b2c:	011b      	lsls	r3, r3, #4
 b2e:	401c      	ands	r4, r3
 b30:	2380      	movs	r3, #128	; 0x80
 b32:	01db      	lsls	r3, r3, #7
 b34:	431c      	orrs	r4, r3
                        GCLK_CLKCTRL_ID(SERCOM0_GCLK_ID_CORE + id);
 b36:	233f      	movs	r3, #63	; 0x3f
 b38:	3514      	adds	r5, #20
 b3a:	401d      	ands	r5, r3
    GCLK->CLKCTRL.reg = GCLK_CLKCTRL_CLKEN |
 b3c:	4b03      	ldr	r3, [pc, #12]	; (b4c <sercomClockEnable+0x44>)
                        GCLK_CLKCTRL_GEN(clock_channel) |
 b3e:	432c      	orrs	r4, r5
    GCLK->CLKCTRL.reg = GCLK_CLKCTRL_CLKEN |
 b40:	805c      	strh	r4, [r3, #2]
}
 b42:	bd70      	pop	{r4, r5, r6, pc}
 b44:	40000400 	.word	0x40000400
 b48:	00000915 	.word	0x00000915
 b4c:	40000c00 	.word	0x40000c00

00000b50 <sercomSpiMasterInit>:
          | (cpol ? SERCOM_SPI_CTRLA_CPOL : 0)
          | (cpha ? SERCOM_SPI_CTRLA_CPHA : 0);
}


void sercomSpiMasterInit(SercomId id, u32_t dipo, u32_t dopo, bool cpol, bool cpha, u8_t baud) {
 b50:	b5f0      	push	{r4, r5, r6, r7, lr}
 b52:	ac05      	add	r4, sp, #20
 b54:	7826      	ldrb	r6, [r4, #0]
 b56:	ac06      	add	r4, sp, #24
 b58:	7827      	ldrb	r7, [r4, #0]
    return (Sercom*) (0x42000800U + id * 1024);
 b5a:	4c13      	ldr	r4, [pc, #76]	; (ba8 <sercomSpiMasterInit+0x58>)
    while(sercom(id)->SPI.CTRLA.reg & SERCOM_SPI_CTRLA_SWRST);
 b5c:	2501      	movs	r5, #1
 b5e:	46a4      	mov	ip, r4
    sercom(id)->SPI.CTRLA.reg = SERCOM_SPI_CTRLA_SWRST;
 b60:	2401      	movs	r4, #1
 b62:	0280      	lsls	r0, r0, #10
 b64:	4460      	add	r0, ip
 b66:	6004      	str	r4, [r0, #0]
    while(sercom(id)->SPI.CTRLA.reg & SERCOM_SPI_CTRLA_SWRST);
 b68:	6804      	ldr	r4, [r0, #0]
 b6a:	402c      	ands	r4, r5
 b6c:	d1fc      	bne.n	b68 <sercomSpiMasterInit+0x18>

    sercomReset(id);

    sercom(id)->SPI.CTRLB.reg
        = SERCOM_SPI_CTRLB_RXEN;
 b6e:	2580      	movs	r5, #128	; 0x80
 b70:	02ad      	lsls	r5, r5, #10
 b72:	6045      	str	r5, [r0, #4]
    sercom(id)->SPI.BAUD.reg = baud;

    sercom(id)->SPI.CTRLA.reg
        = SERCOM_SPI_CTRLA_ENABLE
          | SERCOM_SPI_CTRLA_MODE_SPI_MASTER
          | SERCOM_SPI_CTRLA_DIPO(dipo)
 b74:	25c0      	movs	r5, #192	; 0xc0
 b76:	0509      	lsls	r1, r1, #20
 b78:	03ad      	lsls	r5, r5, #14
 b7a:	4029      	ands	r1, r5
          | SERCOM_SPI_CTRLA_DOPO(dopo)
 b7c:	25c0      	movs	r5, #192	; 0xc0
 b7e:	0412      	lsls	r2, r2, #16
 b80:	02ad      	lsls	r5, r5, #10
 b82:	402a      	ands	r2, r5
 b84:	250e      	movs	r5, #14
 b86:	432a      	orrs	r2, r5
          | (cpol ? SERCOM_SPI_CTRLA_CPOL : 0)
 b88:	1e5d      	subs	r5, r3, #1
 b8a:	41ab      	sbcs	r3, r5
    sercom(id)->SPI.BAUD.reg = baud;
 b8c:	7307      	strb	r7, [r0, #12]
          | (cpol ? SERCOM_SPI_CTRLA_CPOL : 0)
 b8e:	075b      	lsls	r3, r3, #29
 b90:	430a      	orrs	r2, r1
          | (cpha ? SERCOM_SPI_CTRLA_CPHA : 0);
 b92:	2e00      	cmp	r6, #0
 b94:	d001      	beq.n	b9a <sercomSpiMasterInit+0x4a>
 b96:	2480      	movs	r4, #128	; 0x80
 b98:	0564      	lsls	r4, r4, #21
 b9a:	4313      	orrs	r3, r2
 b9c:	431c      	orrs	r4, r3
        = SERCOM_SPI_CTRLA_ENABLE
 b9e:	6004      	str	r4, [r0, #0]
        };
    }
}

static inline void SPI_sync(SercomId id) {
    while  (sercom(id)->SPI.SYNCBUSY.bit.CTRLB);
 ba0:	69c3      	ldr	r3, [r0, #28]
 ba2:	075b      	lsls	r3, r3, #29
 ba4:	d4fc      	bmi.n	ba0 <sercomSpiMasterInit+0x50>

    SPI_sync(id);
}
 ba6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 ba8:	42000800 	.word	0x42000800

00000bac <sercomUartInit>:
    return (Sercom*) (0x42000800U + id * 1024);
 bac:	4b0e      	ldr	r3, [pc, #56]	; (be8 <sercomUartInit+0x3c>)




void sercomUartInit(SercomId id, u32_t rxpo, u32_t txpo, int32_t fBAUD) {
 bae:	b510      	push	{r4, lr}
 bb0:	469c      	mov	ip, r3
    sercom(id)->SPI.CTRLA.reg = SERCOM_SPI_CTRLA_SWRST;
 bb2:	2301      	movs	r3, #1
    while(sercom(id)->SPI.CTRLA.reg & SERCOM_SPI_CTRLA_SWRST);
 bb4:	2401      	movs	r4, #1
 bb6:	0280      	lsls	r0, r0, #10
 bb8:	4460      	add	r0, ip
    sercom(id)->SPI.CTRLA.reg = SERCOM_SPI_CTRLA_SWRST;
 bba:	6003      	str	r3, [r0, #0]
    while(sercom(id)->SPI.CTRLA.reg & SERCOM_SPI_CTRLA_SWRST);
 bbc:	6803      	ldr	r3, [r0, #0]
 bbe:	421c      	tst	r4, r3
 bc0:	d1fc      	bne.n	bbc <sercomUartInit+0x10>

    //float BAUD = 65536*(1-(16*(115200/(48000000/8))));


    sercomReset(id);
    sercom(id)->USART.CTRLA.reg = SERCOM_USART_CTRLA_MODE_USART_INT_CLK;
 bc2:	2304      	movs	r3, #4
 bc4:	6003      	str	r3, [r0, #0]
    sercom(id)->USART.BAUD.reg = 45403;
 bc6:	4b09      	ldr	r3, [pc, #36]	; (bec <sercomUartInit+0x40>)
    sercom(id)->USART.CTRLB.reg
        = SERCOM_USART_CTRLB_RXEN
 bc8:	24c0      	movs	r4, #192	; 0xc0
    sercom(id)->USART.BAUD.reg = 45403;
 bca:	8183      	strh	r3, [r0, #12]
    sercom(id)->USART.CTRLA.reg
        = SERCOM_USART_CTRLA_ENABLE
          | SERCOM_USART_CTRLA_MODE_USART_INT_CLK
          | SERCOM_SPI_CTRLA_DORD
          | SERCOM_USART_CTRLA_TXPO(txpo)
          | SERCOM_USART_CTRLA_RXPO(rxpo);
 bcc:	23c0      	movs	r3, #192	; 0xc0
 bce:	0509      	lsls	r1, r1, #20
 bd0:	039b      	lsls	r3, r3, #14
 bd2:	400b      	ands	r3, r1
 bd4:	4906      	ldr	r1, [pc, #24]	; (bf0 <sercomUartInit+0x44>)
        = SERCOM_USART_CTRLB_RXEN
 bd6:	02a4      	lsls	r4, r4, #10
          | SERCOM_USART_CTRLA_TXPO(txpo)
 bd8:	0412      	lsls	r2, r2, #16
          | SERCOM_USART_CTRLA_RXPO(rxpo);
 bda:	4319      	orrs	r1, r3
          | SERCOM_USART_CTRLA_TXPO(txpo)
 bdc:	4022      	ands	r2, r4
          | SERCOM_USART_CTRLA_RXPO(rxpo);
 bde:	430a      	orrs	r2, r1
        = SERCOM_USART_CTRLB_RXEN
 be0:	6044      	str	r4, [r0, #4]
        = SERCOM_USART_CTRLA_ENABLE
 be2:	6002      	str	r2, [r0, #0]
}
 be4:	bd10      	pop	{r4, pc}
 be6:	46c0      	nop			; (mov r8, r8)
 be8:	42000800 	.word	0x42000800
 bec:	ffffb15b 	.word	0xffffb15b
 bf0:	40000006 	.word	0x40000006

00000bf4 <__divsi3>:
 bf4:	4603      	mov	r3, r0
 bf6:	430b      	orrs	r3, r1
 bf8:	d47f      	bmi.n	cfa <__divsi3+0x106>
 bfa:	2200      	movs	r2, #0
 bfc:	0843      	lsrs	r3, r0, #1
 bfe:	428b      	cmp	r3, r1
 c00:	d374      	bcc.n	cec <__divsi3+0xf8>
 c02:	0903      	lsrs	r3, r0, #4
 c04:	428b      	cmp	r3, r1
 c06:	d35f      	bcc.n	cc8 <__divsi3+0xd4>
 c08:	0a03      	lsrs	r3, r0, #8
 c0a:	428b      	cmp	r3, r1
 c0c:	d344      	bcc.n	c98 <__divsi3+0xa4>
 c0e:	0b03      	lsrs	r3, r0, #12
 c10:	428b      	cmp	r3, r1
 c12:	d328      	bcc.n	c66 <__divsi3+0x72>
 c14:	0c03      	lsrs	r3, r0, #16
 c16:	428b      	cmp	r3, r1
 c18:	d30d      	bcc.n	c36 <__divsi3+0x42>
 c1a:	22ff      	movs	r2, #255	; 0xff
 c1c:	0209      	lsls	r1, r1, #8
 c1e:	ba12      	rev	r2, r2
 c20:	0c03      	lsrs	r3, r0, #16
 c22:	428b      	cmp	r3, r1
 c24:	d302      	bcc.n	c2c <__divsi3+0x38>
 c26:	1212      	asrs	r2, r2, #8
 c28:	0209      	lsls	r1, r1, #8
 c2a:	d065      	beq.n	cf8 <__divsi3+0x104>
 c2c:	0b03      	lsrs	r3, r0, #12
 c2e:	428b      	cmp	r3, r1
 c30:	d319      	bcc.n	c66 <__divsi3+0x72>
 c32:	e000      	b.n	c36 <__divsi3+0x42>
 c34:	0a09      	lsrs	r1, r1, #8
 c36:	0bc3      	lsrs	r3, r0, #15
 c38:	428b      	cmp	r3, r1
 c3a:	d301      	bcc.n	c40 <__divsi3+0x4c>
 c3c:	03cb      	lsls	r3, r1, #15
 c3e:	1ac0      	subs	r0, r0, r3
 c40:	4152      	adcs	r2, r2
 c42:	0b83      	lsrs	r3, r0, #14
 c44:	428b      	cmp	r3, r1
 c46:	d301      	bcc.n	c4c <__divsi3+0x58>
 c48:	038b      	lsls	r3, r1, #14
 c4a:	1ac0      	subs	r0, r0, r3
 c4c:	4152      	adcs	r2, r2
 c4e:	0b43      	lsrs	r3, r0, #13
 c50:	428b      	cmp	r3, r1
 c52:	d301      	bcc.n	c58 <__divsi3+0x64>
 c54:	034b      	lsls	r3, r1, #13
 c56:	1ac0      	subs	r0, r0, r3
 c58:	4152      	adcs	r2, r2
 c5a:	0b03      	lsrs	r3, r0, #12
 c5c:	428b      	cmp	r3, r1
 c5e:	d301      	bcc.n	c64 <__divsi3+0x70>
 c60:	030b      	lsls	r3, r1, #12
 c62:	1ac0      	subs	r0, r0, r3
 c64:	4152      	adcs	r2, r2
 c66:	0ac3      	lsrs	r3, r0, #11
 c68:	428b      	cmp	r3, r1
 c6a:	d301      	bcc.n	c70 <__divsi3+0x7c>
 c6c:	02cb      	lsls	r3, r1, #11
 c6e:	1ac0      	subs	r0, r0, r3
 c70:	4152      	adcs	r2, r2
 c72:	0a83      	lsrs	r3, r0, #10
 c74:	428b      	cmp	r3, r1
 c76:	d301      	bcc.n	c7c <__divsi3+0x88>
 c78:	028b      	lsls	r3, r1, #10
 c7a:	1ac0      	subs	r0, r0, r3
 c7c:	4152      	adcs	r2, r2
 c7e:	0a43      	lsrs	r3, r0, #9
 c80:	428b      	cmp	r3, r1
 c82:	d301      	bcc.n	c88 <__divsi3+0x94>
 c84:	024b      	lsls	r3, r1, #9
 c86:	1ac0      	subs	r0, r0, r3
 c88:	4152      	adcs	r2, r2
 c8a:	0a03      	lsrs	r3, r0, #8
 c8c:	428b      	cmp	r3, r1
 c8e:	d301      	bcc.n	c94 <__divsi3+0xa0>
 c90:	020b      	lsls	r3, r1, #8
 c92:	1ac0      	subs	r0, r0, r3
 c94:	4152      	adcs	r2, r2
 c96:	d2cd      	bcs.n	c34 <__divsi3+0x40>
 c98:	09c3      	lsrs	r3, r0, #7
 c9a:	428b      	cmp	r3, r1
 c9c:	d301      	bcc.n	ca2 <__divsi3+0xae>
 c9e:	01cb      	lsls	r3, r1, #7
 ca0:	1ac0      	subs	r0, r0, r3
 ca2:	4152      	adcs	r2, r2
 ca4:	0983      	lsrs	r3, r0, #6
 ca6:	428b      	cmp	r3, r1
 ca8:	d301      	bcc.n	cae <__divsi3+0xba>
 caa:	018b      	lsls	r3, r1, #6
 cac:	1ac0      	subs	r0, r0, r3
 cae:	4152      	adcs	r2, r2
 cb0:	0943      	lsrs	r3, r0, #5
 cb2:	428b      	cmp	r3, r1
 cb4:	d301      	bcc.n	cba <__divsi3+0xc6>
 cb6:	014b      	lsls	r3, r1, #5
 cb8:	1ac0      	subs	r0, r0, r3
 cba:	4152      	adcs	r2, r2
 cbc:	0903      	lsrs	r3, r0, #4
 cbe:	428b      	cmp	r3, r1
 cc0:	d301      	bcc.n	cc6 <__divsi3+0xd2>
 cc2:	010b      	lsls	r3, r1, #4
 cc4:	1ac0      	subs	r0, r0, r3
 cc6:	4152      	adcs	r2, r2
 cc8:	08c3      	lsrs	r3, r0, #3
 cca:	428b      	cmp	r3, r1
 ccc:	d301      	bcc.n	cd2 <__divsi3+0xde>
 cce:	00cb      	lsls	r3, r1, #3
 cd0:	1ac0      	subs	r0, r0, r3
 cd2:	4152      	adcs	r2, r2
 cd4:	0883      	lsrs	r3, r0, #2
 cd6:	428b      	cmp	r3, r1
 cd8:	d301      	bcc.n	cde <__divsi3+0xea>
 cda:	008b      	lsls	r3, r1, #2
 cdc:	1ac0      	subs	r0, r0, r3
 cde:	4152      	adcs	r2, r2
 ce0:	0843      	lsrs	r3, r0, #1
 ce2:	428b      	cmp	r3, r1
 ce4:	d301      	bcc.n	cea <__divsi3+0xf6>
 ce6:	004b      	lsls	r3, r1, #1
 ce8:	1ac0      	subs	r0, r0, r3
 cea:	4152      	adcs	r2, r2
 cec:	1a41      	subs	r1, r0, r1
 cee:	d200      	bcs.n	cf2 <__divsi3+0xfe>
 cf0:	4601      	mov	r1, r0
 cf2:	4152      	adcs	r2, r2
 cf4:	4610      	mov	r0, r2
 cf6:	4770      	bx	lr
 cf8:	e05d      	b.n	db6 <__divsi3+0x1c2>
 cfa:	0fca      	lsrs	r2, r1, #31
 cfc:	d000      	beq.n	d00 <__divsi3+0x10c>
 cfe:	4249      	negs	r1, r1
 d00:	1003      	asrs	r3, r0, #32
 d02:	d300      	bcc.n	d06 <__divsi3+0x112>
 d04:	4240      	negs	r0, r0
 d06:	4053      	eors	r3, r2
 d08:	2200      	movs	r2, #0
 d0a:	469c      	mov	ip, r3
 d0c:	0903      	lsrs	r3, r0, #4
 d0e:	428b      	cmp	r3, r1
 d10:	d32d      	bcc.n	d6e <__divsi3+0x17a>
 d12:	0a03      	lsrs	r3, r0, #8
 d14:	428b      	cmp	r3, r1
 d16:	d312      	bcc.n	d3e <__divsi3+0x14a>
 d18:	22fc      	movs	r2, #252	; 0xfc
 d1a:	0189      	lsls	r1, r1, #6
 d1c:	ba12      	rev	r2, r2
 d1e:	0a03      	lsrs	r3, r0, #8
 d20:	428b      	cmp	r3, r1
 d22:	d30c      	bcc.n	d3e <__divsi3+0x14a>
 d24:	0189      	lsls	r1, r1, #6
 d26:	1192      	asrs	r2, r2, #6
 d28:	428b      	cmp	r3, r1
 d2a:	d308      	bcc.n	d3e <__divsi3+0x14a>
 d2c:	0189      	lsls	r1, r1, #6
 d2e:	1192      	asrs	r2, r2, #6
 d30:	428b      	cmp	r3, r1
 d32:	d304      	bcc.n	d3e <__divsi3+0x14a>
 d34:	0189      	lsls	r1, r1, #6
 d36:	d03a      	beq.n	dae <__divsi3+0x1ba>
 d38:	1192      	asrs	r2, r2, #6
 d3a:	e000      	b.n	d3e <__divsi3+0x14a>
 d3c:	0989      	lsrs	r1, r1, #6
 d3e:	09c3      	lsrs	r3, r0, #7
 d40:	428b      	cmp	r3, r1
 d42:	d301      	bcc.n	d48 <__divsi3+0x154>
 d44:	01cb      	lsls	r3, r1, #7
 d46:	1ac0      	subs	r0, r0, r3
 d48:	4152      	adcs	r2, r2
 d4a:	0983      	lsrs	r3, r0, #6
 d4c:	428b      	cmp	r3, r1
 d4e:	d301      	bcc.n	d54 <__divsi3+0x160>
 d50:	018b      	lsls	r3, r1, #6
 d52:	1ac0      	subs	r0, r0, r3
 d54:	4152      	adcs	r2, r2
 d56:	0943      	lsrs	r3, r0, #5
 d58:	428b      	cmp	r3, r1
 d5a:	d301      	bcc.n	d60 <__divsi3+0x16c>
 d5c:	014b      	lsls	r3, r1, #5
 d5e:	1ac0      	subs	r0, r0, r3
 d60:	4152      	adcs	r2, r2
 d62:	0903      	lsrs	r3, r0, #4
 d64:	428b      	cmp	r3, r1
 d66:	d301      	bcc.n	d6c <__divsi3+0x178>
 d68:	010b      	lsls	r3, r1, #4
 d6a:	1ac0      	subs	r0, r0, r3
 d6c:	4152      	adcs	r2, r2
 d6e:	08c3      	lsrs	r3, r0, #3
 d70:	428b      	cmp	r3, r1
 d72:	d301      	bcc.n	d78 <__divsi3+0x184>
 d74:	00cb      	lsls	r3, r1, #3
 d76:	1ac0      	subs	r0, r0, r3
 d78:	4152      	adcs	r2, r2
 d7a:	0883      	lsrs	r3, r0, #2
 d7c:	428b      	cmp	r3, r1
 d7e:	d301      	bcc.n	d84 <__divsi3+0x190>
 d80:	008b      	lsls	r3, r1, #2
 d82:	1ac0      	subs	r0, r0, r3
 d84:	4152      	adcs	r2, r2
 d86:	d2d9      	bcs.n	d3c <__divsi3+0x148>
 d88:	0843      	lsrs	r3, r0, #1
 d8a:	428b      	cmp	r3, r1
 d8c:	d301      	bcc.n	d92 <__divsi3+0x19e>
 d8e:	004b      	lsls	r3, r1, #1
 d90:	1ac0      	subs	r0, r0, r3
 d92:	4152      	adcs	r2, r2
 d94:	1a41      	subs	r1, r0, r1
 d96:	d200      	bcs.n	d9a <__divsi3+0x1a6>
 d98:	4601      	mov	r1, r0
 d9a:	4663      	mov	r3, ip
 d9c:	4152      	adcs	r2, r2
 d9e:	105b      	asrs	r3, r3, #1
 da0:	4610      	mov	r0, r2
 da2:	d301      	bcc.n	da8 <__divsi3+0x1b4>
 da4:	4240      	negs	r0, r0
 da6:	2b00      	cmp	r3, #0
 da8:	d500      	bpl.n	dac <__divsi3+0x1b8>
 daa:	4249      	negs	r1, r1
 dac:	4770      	bx	lr
 dae:	4663      	mov	r3, ip
 db0:	105b      	asrs	r3, r3, #1
 db2:	d300      	bcc.n	db6 <__divsi3+0x1c2>
 db4:	4240      	negs	r0, r0
 db6:	b501      	push	{r0, lr}
 db8:	2000      	movs	r0, #0
 dba:	f000 f805 	bl	dc8 <__aeabi_idiv0>
 dbe:	bd02      	pop	{r1, pc}

00000dc0 <__aeabi_idivmod>:
 dc0:	2900      	cmp	r1, #0
 dc2:	d0f8      	beq.n	db6 <__divsi3+0x1c2>
 dc4:	e716      	b.n	bf4 <__divsi3>
 dc6:	4770      	bx	lr

00000dc8 <__aeabi_idiv0>:
 dc8:	4770      	bx	lr
 dca:	46c0      	nop			; (mov r8, r8)

00000dcc <__libc_init_array>:
 dcc:	b570      	push	{r4, r5, r6, lr}
 dce:	2600      	movs	r6, #0
 dd0:	4d0c      	ldr	r5, [pc, #48]	; (e04 <__libc_init_array+0x38>)
 dd2:	4c0d      	ldr	r4, [pc, #52]	; (e08 <__libc_init_array+0x3c>)
 dd4:	1b64      	subs	r4, r4, r5
 dd6:	10a4      	asrs	r4, r4, #2
 dd8:	42a6      	cmp	r6, r4
 dda:	d109      	bne.n	df0 <__libc_init_array+0x24>
 ddc:	2600      	movs	r6, #0
 dde:	f000 f82b 	bl	e38 <_init>
 de2:	4d0a      	ldr	r5, [pc, #40]	; (e0c <__libc_init_array+0x40>)
 de4:	4c0a      	ldr	r4, [pc, #40]	; (e10 <__libc_init_array+0x44>)
 de6:	1b64      	subs	r4, r4, r5
 de8:	10a4      	asrs	r4, r4, #2
 dea:	42a6      	cmp	r6, r4
 dec:	d105      	bne.n	dfa <__libc_init_array+0x2e>
 dee:	bd70      	pop	{r4, r5, r6, pc}
 df0:	00b3      	lsls	r3, r6, #2
 df2:	58eb      	ldr	r3, [r5, r3]
 df4:	4798      	blx	r3
 df6:	3601      	adds	r6, #1
 df8:	e7ee      	b.n	dd8 <__libc_init_array+0xc>
 dfa:	00b3      	lsls	r3, r6, #2
 dfc:	58eb      	ldr	r3, [r5, r3]
 dfe:	4798      	blx	r3
 e00:	3601      	adds	r6, #1
 e02:	e7f2      	b.n	dea <__libc_init_array+0x1e>
 e04:	00000e44 	.word	0x00000e44
 e08:	00000e44 	.word	0x00000e44
 e0c:	00000e44 	.word	0x00000e44
 e10:	00000e48 	.word	0x00000e48

00000e14 <memcpy>:
 e14:	2300      	movs	r3, #0
 e16:	b510      	push	{r4, lr}
 e18:	429a      	cmp	r2, r3
 e1a:	d100      	bne.n	e1e <memcpy+0xa>
 e1c:	bd10      	pop	{r4, pc}
 e1e:	5ccc      	ldrb	r4, [r1, r3]
 e20:	54c4      	strb	r4, [r0, r3]
 e22:	3301      	adds	r3, #1
 e24:	e7f8      	b.n	e18 <memcpy+0x4>

00000e26 <memset>:
 e26:	0003      	movs	r3, r0
 e28:	1882      	adds	r2, r0, r2
 e2a:	4293      	cmp	r3, r2
 e2c:	d100      	bne.n	e30 <memset+0xa>
 e2e:	4770      	bx	lr
 e30:	7019      	strb	r1, [r3, #0]
 e32:	3301      	adds	r3, #1
 e34:	e7f9      	b.n	e2a <memset+0x4>
	...

00000e38 <_init>:
 e38:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 e3a:	46c0      	nop			; (mov r8, r8)
 e3c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 e3e:	bc08      	pop	{r3}
 e40:	469e      	mov	lr, r3
 e42:	4770      	bx	lr

00000e44 <__init_array_start>:
 e44:	000000dd 	.word	0x000000dd

00000e48 <_fini>:
 e48:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 e4a:	46c0      	nop			; (mov r8, r8)
 e4c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 e4e:	bc08      	pop	{r3}
 e50:	469e      	mov	lr, r3
 e52:	4770      	bx	lr

00000e54 <__fini_array_start>:
 e54:	000000b5 	.word	0x000000b5
